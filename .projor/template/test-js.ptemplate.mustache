{
    "map": {
        "entities": "entities"
    },
    "filename": "test/index.test.js",
    "formatUsing": "babel"
}
---
const client = require('../lib/index');
const { expect } = require('chai');

function randomString(length = 10) {
    return Math.random().toString(36).substring(2, 2 + length);
}

function randomInteger(min = 0, max = 100000) {
    return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomBoolean() {
    return Math.random() >= 0.5;
}

function randomFloat(min = 0, max = 1000) {
    return Math.random() * (max - min) + min;
}

function randomDouble(min = 0, max = 1000) {
    return Math.random() * (max - min) + min;
}

function randomLocalTime() {
    let randomHour = randomInteger(0, 23);
    let randomMinute = randomInteger(0, 59);
    let randomSecond = randomInteger(0, 59);
    return `${randomHour < 10 ? '0' : ''}${randomHour}:${randomMinute < 10 ? '0' : ''}${randomMinute}:${randomSecond < 10 ? '0' : ''}${randomSecond}`;
}

function randomLocalDate() {
    const oneYearMs = 1000 * 60 * 60 * 24 * 365;
    const randomMs = 2 * Math.floor(Math.random() * oneYearMs) - oneYearMs;
    const randomDate = new Date(Date.now() + randomMs);
    return randomDate.toISOString().split('T')[0];
}

function randomInstant() {
    return `${randomLocalDate()}T${randomLocalTime()}Z`;
}

describe(
    '{{capitalCase $.client.name}} Tests', () => {

        const backendUrl = process.env.{{constantCase $.client.name}}_TEST_BACKEND_URL || `{{$.backend.apiUrl}}`;
        const authLoginName = process.env.{{constantCase $.client.name}}_TEST_AUTH_LOGIN_NAME || 'admin';
        const authLoginPassword = process.env.{{constantCase $.client.name}}_TEST_AUTH_LOGIN_PASSWORD || 'admin';
        const authJwtToken = process.env.{{constantCase $.client.name}}_TEST_AUTH_JWT_TOKEN || null;
        
        {{#each entities}}
        describe(
            '{{capitalCase name}} Service Tests ({{../$.backend.apiUrl}}/{{kebabCase name}})',
            () => {

                var clientOpts = null;

                const prepareClientOpts = async () => {

                    if (clientOpts) {
                        return;
                    }

                    {{#if (equals ../$.authStyle "none")}}
                    clientOpts = {
                        baseUrl: backendUrl,
                        headers: {}
                    };
                    {{/if}}

                    {{#if (equals ../$.authStyle "jwt")}}
                    if (!authJwtToken) {
                        throw new Error("Cannot run tests: missing JWT token in test configuration ({{constantCase ../$.client.name}}_TEST_AUTH_JWT_TOKEN variable)");
                    }
                    clientOpts = {
                        baseUrl: backendUrl,
                        headers: {
                            Authorization: `Bearer ${authJwtToken}`
                        }
                    };
                    {{/if}}

                    {{#if (equals ../$.authStyle "login")}}
                    if (!authLoginName || !authLoginPassword) {
                        throw new Error("Cannot run tests: missing login credentials in test configuration ({{constantCase ../$.client.name}}_TEST_AUTH_LOGIN_NAME and {{constantCase ../$.client.name}}_TEST_AUTH_LOGIN_PASSWORD variables)");
                    }
                    const authSvc = client.create{{pascalCase ../$.backend.name}}AuthService(backendUrl);
                    const { clientOptions } = await authSvc.login(authLoginName, authLoginPassword);
                    clientOpts = clientOptions;
                    {{/if}}

                }

                const createService = async () => {
                    await prepareClientOpts();
                    return client.create{{pascalCase name}}Service(clientOpts);
                };

                it(
                    "GET / (no opts)",
                    async () => {
                        const service = await createService();
                        const list = await service.listAll();
                        expect(list).to.be.an('array');
                    }
                );

                it(
                    "GET / (with opts)",
                    async () => {
                        const service = await createService();
                        const list = await service.listAll({
                            offset: 10,
                            limit: 10,
                            sort: 'id__desc'
                        });
                        expect(list).to.be.an('array');
                        expect(list.length).to.be.lessThanOrEqual(10);
                    }
                );

                it(
                    "GET /count",
                    async () => {
                        const service = await createService();
                        const count = await service.countAll();
                        expect(count).to.be.greaterThanOrEqual(0);
                    }
                );

                // New test: Create a new entity with random attributes and null associations
                it(
                    "POST / - create new {{capitalCase name}} with null associations",
                    async () => {
                        const service = await createService();
                        const new{{pascalCase name}} = {
                            {{#each attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{#each associations}}
                            {{camelCase name}}: null,
                            {{/each}}
                        };
                        const created{{pascalCase name}} = await service.create(new{{pascalCase name}});
                        expect(created{{pascalCase name}}).to.be.an('object');
                        expect(created{{pascalCase name}}).to.have.property('id');
                        {{#each attributes}}
                        expect(created{{pascalCase ../name}}).to.have.property('{{camelCase name}}', new{{pascalCase ../name}}.{{camelCase name}});
                        {{/each}}
                    }
                );

                it(
                    "GET /:id",
                    async () => {
                        const service = await createService();
                        const new{{pascalCase name}} = {
                            {{#each attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{#each associations}}
                            {{camelCase name}}: null,
                            {{/each}}
                        };
                        const created{{pascalCase name}} = await service.create(new{{pascalCase name}});
                        const id = created{{pascalCase name}}.id;
                        const retrieved{{pascalCase name}} = await service.getById(id);
                        expect(retrieved{{pascalCase name}}).to.be.an('object');
                        expect(retrieved{{pascalCase name}}).to.have.property('id', id);
                    }
                );

                // New test: Create a new entity with random attributes and non-null associations
                it(
                    "POST / - create new {{capitalCase name}} with non-null associations",
                    async () => {
                        const service = await createService();

                        // Create related entities for associations
                        const associations = {};
                        {{#each associations}}
                        // Assuming the associated entity is {{pascalCase type.name}}
                        const related{{pascalCase name}}Service = await client.create{{pascalCase type.name}}Service(clientOpts);
                        const related{{pascalCase name}} = await related{{pascalCase name}}Service.create({
                            {{#each type.attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                        });
                        associations['{{camelCase name}}Id'] = related{{pascalCase name}}.id;
                        {{/each}}

                        const new{{pascalCase name}} = {
                            {{#each attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            ...associations
                        };

                        const created{{pascalCase name}} = await service.create(new{{pascalCase name}});
                        expect(created{{pascalCase name}}).to.be.an('object');
                        expect(created{{pascalCase name}}).to.have.property('id');
                        {{#each attributes}}
                        expect(created{{pascalCase ../name}}).to.have.property('{{camelCase name}}', new{{pascalCase ../name}}.{{camelCase name}});
                        {{/each}}
                        {{#each associations}}
                        expect(created{{pascalCase ../name}}).to.have.property('{{camelCase name}}Id', associations['{{camelCase name}}Id']);
                        {{/each}}
                    }
                );

                // New test: Update an attribute with a random value
                {{#each attributes}}
                it(
                    "POST /:id/{{camelCase name}} - update attribute {{camelCase name}}",
                    async () => {
                        const service = await createService();
                        // Create a new entity
                        const new{{pascalCase ../name}} = {
                            {{#each ../attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{#each ../associations}}
                            {{camelCase name}}Id: null,
                            {{/each}}
                        };
                        const created{{pascalCase ../name}} = await service.create(new{{pascalCase ../name}});
                        const id = created{{pascalCase ../name}}.id;
                        // Update the attribute
                        const updatedValue = random{{pascalCase type.name}}();
                        await service.update{{pascalCase name}}(id, updatedValue); // Returns Promise<void>
                        // Retrieve and verify the updated entity
                        const updated{{pascalCase ../name}} = await service.getById(id);
                        expect(updated{{pascalCase ../name}}).to.have.property('{{camelCase name}}', updatedValue);
                    }
                );
                {{/each}}

                // New test: Clear an attribute
                {{#each attributes}}
                {{#unless validation.isNotNull}}
                {{#unless validation.isNotEmpty}}
                it(
                    "DELETE /:id/{{camelCase name}} - clear attribute {{camelCase name}}",
                    async () => {
                        const service = await createService();
                        // Create a new entity with the attribute set
                        const new{{pascalCase ../name}} = {
                            {{#each ../attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{#each ../associations}}
                            {{camelCase name}}Id: null,
                            {{/each}}
                        };
                        const created{{pascalCase ../name}} = await service.create(new{{pascalCase ../name}});
                        const id = created{{pascalCase ../name}}.id;
                        // Clear the attribute
                        await service.clear{{pascalCase name}}(id); // Returns Promise<void>
                        // Retrieve and verify the attribute is cleared
                        const updated{{pascalCase ../name}} = await service.getById(id);
                        expect(updated{{pascalCase ../name}}).to.have.property('{{camelCase name}}').that.is.null;
                    }
                );
                {{/unless}}
                {{/unless}}
                {{/each}}

                // New test: Update an association with null and non-null values
                {{#each associations}}
                it(
                    "POST /:id/{{camelCase name}} - update association {{camelCase name}} with non-null value",
                    async () => {
                        const service = await createService();
                        // Create related entity
                        const related{{pascalCase name}}Service = await client.create{{pascalCase type.name}}Service(clientOpts);
                        const related{{pascalCase name}} = await related{{pascalCase name}}Service.create({
                            {{#each type.attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                        });
                        // Create a new entity
                        const new{{pascalCase ../name}} = {
                            {{#each ../attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{camelCase name}}Id: null
                        };
                        const created{{pascalCase ../name}} = await service.create(new{{pascalCase ../name}});
                        const id = created{{pascalCase ../name}}.id;
                        // Update the association
                        await service.update{{pascalCase name}}(id, related{{pascalCase name}}.id); // Returns Promise<void>
                        // Retrieve and verify the updated entity
                        const updated{{pascalCase ../name}} = await service.getById(id);
                        expect(updated{{pascalCase ../name}}).to.have.property('{{camelCase name}}Id', related{{pascalCase name}}.id);
                    }
                );

                it(
                    "DELETE /:id/{{camelCase name}} - clear association {{camelCase name}}",
                    async () => {
                        const service = await createService();
                        // Create related entity
                        const related{{pascalCase name}}Service = await client.create{{pascalCase type.name}}Service(clientOpts);
                        const related{{pascalCase name}} = await related{{pascalCase name}}Service.create({
                            {{#each type.attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                        });
                        // Create a new entity with the association set
                        const new{{pascalCase ../name}} = {
                            {{#each ../attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{camelCase name}}Id: related{{pascalCase name}}.id
                        };
                        const created{{pascalCase ../name}} = await service.create(new{{pascalCase ../name}});
                        const id = created{{pascalCase ../name}}.id;
                        // Clear the association
                        await service.clear{{pascalCase name}}(id); // Returns Promise<void>
                        // Retrieve and verify the association is cleared
                        const updated{{pascalCase ../name}} = await service.getById(id);
                        expect(updated{{pascalCase ../name}}['{{camelCase name}}Id']).to.be.null;
                    }
                );
                {{/each}}

                // New test: Delete an entity
                it(
                    "DELETE /:id - remove {{capitalCase name}}",
                    async () => {
                        const service = await createService();
                        // Create a new entity
                        const new{{pascalCase name}} = {
                            {{#each attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{#each associations}}
                            {{camelCase name}}Id: null,
                            {{/each}}
                        };
                        const created{{pascalCase name}} = await service.create(new{{pascalCase name}});
                        const id = created{{pascalCase name}}.id;
                        // Delete the entity
                        await service.remove(id);
                        // Verify the entity has been deleted
                        let error = null;
                        try {
                            await service.getById(id);
                        } catch (err) {
                            error = err;
                        }
                        expect(error).to.not.be.null;
                    }
                );

                // New test: Search entities
                it(
                    "POST /search - search {{capitalCase name}} entities",
                    async () => {
                        const service = await createService();
                        // Create a unique attribute value for testing
                        const uniqueValue = `test-${randomString(5)}-${Date.now()}`;
                        // Create a new entity with the unique value
                        const new{{pascalCase name}} = {
                            {{#each attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{#each associations}}
                            {{camelCase name}}Id: null,
                            {{/each}}
                        };
                        const created{{pascalCase name}} = await service.create(new{{pascalCase name}});
                        // Search for the entity using the unique attribute
                        const filter = {
                            and: [
                                {
                                    id: {
                                        in: [created{{pascalCase name}}.id]
                                    }
                                },
                                {
                                    id: {
                                        notIn: [uniqueValue]
                                    }
                                }
                            ]
                        };
                        const results = await service.search(filter);
                        expect(results).to.be.an('array');
                        const found = results.some(e => e.id === created{{pascalCase name}}.id);
                        expect(found).to.be.true;
                    }
                );

                // New test: Count entities matching a filter
                it(
                    "POST /search/count - count {{capitalCase name}} entities matching a filter",
                    async () => {
                        const service = await createService();
                        // Create a unique attribute value for testing
                        const uniqueValue = `test-${randomString(5)}-${Date.now()}`;
                        // Create a new entity with the unique value
                        const new{{pascalCase name}} = {
                            {{#each attributes}}
                            {{camelCase name}}: random{{pascalCase type.name}}(),
                            {{/each}}
                            {{#each associations}}
                            {{camelCase name}}Id: null,
                            {{/each}}
                        };
                        const created{{pascalCase name}} = await service.create(new{{pascalCase name}});
                        // Count entities matching the filter
                        const filter = {
                            and: [
                                {
                                    id: {
                                        in: [created{{pascalCase name}}.id]
                                    }
                                },
                                {
                                    id: {
                                        notIn: [uniqueValue]
                                    }
                                }
                            ]
                        };
                        const count = await service.countFor(filter);
                        expect(count).to.be.a('number');
                        expect(count).to.be.greaterThanOrEqual(1);
                    }
                );

            }
        );
        {{/each}}

    }
);