{
  "generatedSource": [
    {
      "filename": ".gitignore",
      "content": "# Gitignore for Gradle and Java\r\n\r\nHELP.md\r\n.gradle\r\nbuild/\r\n!gradle/wrapper/gradle-wrapper.jar\r\n!**/src/main/**/build/\r\n!**/src/test/**/build/\r\n\r\n### STS ###\r\n.apt_generated\r\n.classpath\r\n.factorypath\r\n.project\r\n.settings\r\n.springBeans\r\n.sts4-cache\r\nbin/\r\n!**/src/main/**/bin/\r\n!**/src/test/**/bin/\r\n\r\n### IntelliJ IDEA ###\r\n.idea\r\n*.iws\r\n*.iml\r\n*.ipr\r\nout/\r\n!**/src/main/**/out/\r\n!**/src/test/**/out/\r\n\r\n### NetBeans ###\r\n/nbproject/private/\r\n/nbbuild/\r\n/dist/\r\n/nbdist/\r\n/.nb-gradle/\r\n\r\n### VS Code ###\r\n.vscode/\r\n\r\n# Git ignore for NPM\r\n\r\nnode_modules/",
      "contentHash": "bc2bad79774ec47fd1031b00a7102a955bcc29a4c10367ab545de41ea21c5019",
      "noWriteIfExists": false
    },
    {
      "filename": "ENTITIES.md",
      "content": "# Organization Unit\r\n\r\nNo description.\r\n\r\n_Attributes_\r\n\r\n* Name : `String` - No description.\r\n\r\n\r\n\r\n_Reverse Associations_\r\n\r\n* Employees : `[]Employee` (mapped by `Employee :: Org Unit`) - Employees in the org unit\r\n\r\n\r\n# Employee\r\n\r\nAn employee\r\n\r\n_Attributes_\r\n\r\n* First Name : `String` - No description.\r\n* Last Name : `String` - No description.\r\n* Birth Date : `LocalDate` - No description.\r\n* Last Seen At : `Instant` - No description.\r\n\r\n\r\n_Associations_\r\n\r\n* Org Unit : `Organization Unit` - Org unit of employee\r\n\r\n\r\n\r\n# Shift\r\n\r\nNo description.\r\n\r\n_Attributes_\r\n\r\n* Begins At : `LocalTime` - No description.\r\n* Ends At : `LocalTime` - No description.\r\n\r\n\r\n\r\n\r\n",
      "contentHash": "5e33f21d4287e0e42f30a81154bc7f1b81509f55616daab71f8015bea9586d42",
      "noWriteIfExists": false
    },
    {
      "filename": "package.json",
      "content": "{\n    \"name\": \"@example/client\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"description\": \"_You can edit this description in [`.projor/project.pglobal.yaml`](.projor/project.pglobal.yaml)_\",\n    \"main\": \"lib/index.js\",\n    \"types\": \"types/index.d.ts\",\n    \"devDependencies\": {\n        \"@types/node\": \"^22.6.1\",\n        \"typescript\": \"^5.6.2\",\n        \"chai\": \"^4.5.0\",\n        \"mocha\": \"^10.7.3\"\n    },\n    \"scripts\": {\n        \"build\": \"tsc\",\n        \"test\": \"mocha\"\n    }\n}\n",
      "contentHash": "7aac944b237122d580ecea43f977d4907a3491de02faad3f7eca7190e728290f",
      "noWriteIfExists": false
    },
    {
      "filename": "README.md",
      "content": "# Client\r\n\r\nThis is a [ProJor](https://projor.io) template, that generates a _TypeScript Node.JS Client Library_ for a _CRUD API_. See the [`.entities`](.projor/.entities) file on how to define the supported resources.\r\n\r\nThe API supported by this client is the same as the one provided by CRUD API Web Service templates, such as [template-spring-boot-crud](https://github.com/SIOCODE-Open/template-spring-boot-crud).\r\n\r\n[See README inside .projor/ for template customization details and internals](.projor/README.md).\r\n\r\n_You can edit this description in [`.projor/project.pglobal.yaml`](.projor/project.pglobal.yaml)_\r\n\r\n## License\r\n\r\nThis template is licensed under the [MIT License](LICENSE.md).\r\n\r\n[ProJor](https://projor.io) is licensed under either the [ProJor Free License](https://license.projor.io) or the [ProJor Commercial License](https://license.projor.io).",
      "contentHash": "240abf403eb54f22bd645247187504837b1ca04498eb5bab92c972fd11f12388",
      "noWriteIfExists": false
    },
    {
      "filename": "src/index.ts",
      "content": "/** Options for the client services of Backend */\nexport interface IBackendClientOptions {\n    /**\n     * The base URL of the Backend API.\n     * Default: http://localhost:8080/backend/v1\n     */\n    baseUrl?: string;\n    /**\n     * Additional headers to include in requests to the Backend API.\n     * Default: {}\n     */\n    headers?: Record<string, string>;\n    /**\n     * The API key to use for requests to the Backend API. MUST be supplied!\n     */\n    apiKey: string;\n}\n\n/** Options for listing, such as paging and sorting */\nexport interface IBackendListingOptions<TSort extends string> {\n    /**\n     * The offset to start listing from\n     */\n    offset: number;\n\n    /**\n     * The maximum number of items to list\n     */\n    limit: number;\n\n    /**\n     * The field to sort by\n     */\n    sort?: TSort;\n}\n\n/**\n * Helper function to create the listing query parameter string from the listing client parameters object.\n * @param listParams The listing client parameters object\n * @returns The query parameter string\n */\nfunction _listParams<TSort extends string>(\n    listParams?: IBackendListingOptions<TSort>\n): string {\n    if (!listParams) {\n        return \"\";\n    }\n    const params = new URLSearchParams();\n    params.append(\"offset\", listParams.offset.toString());\n    params.append(\"limit\", listParams.limit.toString());\n    if (listParams.sort) {\n        params.append(\"sort\", listParams.sort);\n    }\n    return `?${params.toString()}`;\n}\n\n/**\n * Helper function to make a request using fetch to the Backend API.\n * @param opts The request options\n * @returns The response from the API\n */\nasync function _makeRequest(\n    baseUrl: string,\n    headers: Record<string, any>,\n    opts: {\n        path?: string;\n        query?: string;\n        method: string;\n        body?: any;\n        asText?: boolean;\n        noOp?: boolean;\n    }\n): Promise<any> {\n    let queryString = \"\";\n    if (typeof opts.query === \"string\" && opts.query.length > 0) {\n        if (opts.query.startsWith(\"?\")) {\n            queryString = opts.query;\n        } else {\n            queryString = `?${opts.query}`;\n        }\n    }\n\n    let response = null;\n\n    try {\n        response = await fetch(`${baseUrl}${opts.path || \"\"}${queryString}`, {\n            method: opts.method,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                Accept: \"application/json\",\n                ...headers,\n            },\n            body: JSON.stringify(opts.body),\n        });\n    } catch (err: any) {\n        // FIXME: Better client error handling\n        throw new Error(\n            `Fetch failed (host probably down) ${opts.method} ${\n                opts.path || \"/\"\n            } @ ${baseUrl}: ${err}`\n        );\n    }\n    if (!response.ok) {\n        // FIXME: Better client error handling\n        throw new Error(\n            `Failed calling ${opts.method} ${opts.path || \"/\"} @ ${baseUrl}: ${\n                response.status\n            } ${response.statusText}`\n        );\n    }\n    if (opts.noOp) {\n        return { ok: true };\n    }\n    if (opts.asText) {\n        return await response.text();\n    }\n    return await response.json();\n}\n\n/** No description. */\nexport interface IOrganizationUnit {\n    /** The unique identifier for this Organization Unit */\n    id: string;\n\n    /** No description. */\n    name: string;\n}\n\n/** DTO for a new Organization Unit */\nexport interface INewOrganizationUnit {\n    /** No description. */\n    name?: string | null;\n}\n\n/** DTO for filtering Organization Unit objects */\nexport interface IOrganizationUnitFilter {\n    and?: Array<IOrganizationUnitFilter>;\n    or?: Array<IOrganizationUnitFilter>;\n    not?: IOrganizationUnitFilter;\n    name?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n        contains?: string;\n        notContains?: string;\n        startsWith?: string;\n        notStartsWith?: string;\n        endsWith?: string;\n        notEndsWith?: string;\n    };\n    id?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n    };\n}\n\nexport type IOrganizationUnitSort =\n    | \"id__asc\"\n    | \"id__desc\"\n    | \"name__asc\"\n    | \"name__desc\";\n\nexport interface IOrganizationUnitService {\n    /**\n     * List all Organization Unit objects, optionally applying paging and sorting.\n     * @param opts Options for paging and sorting\n     * @returns A list of Organization Unit objects\n     */\n    listAll(\n        opts?: IBackendListingOptions<IOrganizationUnitSort>\n    ): Promise<Array<IOrganizationUnit>>;\n\n    /**\n     * Get a Organization Unit object by its unique identifier.\n     * @param id The unique identifier of the Organization Unit object\n     * @returns The Organization Unit object. Throws an error if not found.\n     */\n    getById(id: string): Promise<IOrganizationUnit>;\n\n    /**\n     * Count the total number of Organization Unit objects.\n     * @returns The total number of Organization Unit objects\n     */\n    countAll(): Promise<number>;\n\n    /**\n     * Search for Organization Unit objects using a filter, optionally applying paging and sorting.\n     * @param filter The filter to apply\n     * @param opts Options for paging and sorting\n     * @returns A list of filtered Organization Unit objects\n     */\n    search(\n        filter: IOrganizationUnitFilter,\n        opts?: IBackendListingOptions<IOrganizationUnitSort>\n    );\n\n    /**\n     * Count the total number of Organization Unit objects that match a filter.\n     * @param filter The filter to apply\n     * @returns The total number of Organization Unit objects that match the filter\n     */\n    countFor(filter: IOrganizationUnitFilter): Promise<number>;\n\n    /**\n     * Get the Employees of a Organization Unit object by its unique identifier.\n     * @param id The unique identifier of the Organization Unit object\n     * @returns The Employees of the given Organization Unit object. Throws an error if the Organization Unit object is not found.\n     */\n    getEmployeesOf(id: string): Promise<Array<IEmployee>>;\n\n    /**\n     * Create a new Organization Unit object.\n     * @param newOrganizationUnit The new Organization Unit object to create\n     * @returns The newly created Organization Unit object\n     */\n    create(\n        newOrganizationUnit: INewOrganizationUnit\n    ): Promise<IOrganizationUnit>;\n\n    /**\n     * Create or update a list of Organization Unit objects. Each object will either be created or updated.\n     * @param newOrUpdatedEntities The list of Organization Unit objects to create or update\n     * @returns The list of newly created or updated Organization Unit objects\n     */\n    upsert(\n        newOrUpdatedEntities: Array<IOrganizationUnit>\n    ): Promise<Array<IOrganizationUnit>>;\n\n    /**\n     * Update a Organization Unit object by its unique identifier. Requires a value for ALL FIELDS of the object. Nulls will be interpreted as clearing the field. Missing fields will be nulls.\n     * @param id The unique identifier of the Organization Unit object\n     * @param updatedOrganizationUnit The updated Organization Unit object\n     */\n    fullUpdate(\n        id: string,\n        updatedOrganizationUnit: INewOrganizationUnit\n    ): Promise<void>;\n\n    /**\n     * Update a Organization Unit object by its unique identifier. Requires a value for at least one field of the object. Nulls and missing fields will be ignored.\n     * @param id The unique identifier of the Organization Unit object\n     * @param updatedFields The fields to update\n     */\n    partialUpdate(\n        id: string,\n        updatedFields: Partial<INewOrganizationUnit>\n    ): Promise<void>;\n\n    /**\n     * Update the name field of a Organization Unit object by its unique identifier.\n     * @param id The unique identifier of the Organization Unit object\n     * @param name The new value for the name field\n     */\n    updateName(id: string, name: string): Promise<void>;\n\n    /**\n     * Clear the name field of a Organization Unit object by its unique identifier.\n     * @param id The unique identifier of the Organization Unit object\n     */\n    clearName(id: string): Promise<void>;\n\n    /**\n     * Remove a Organization Unit object by its unique identifier.\n     * @param id The unique identifier of the Organization Unit object\n     */\n    remove(id: string): Promise<void>;\n}\n\nclass OrganizationUnitServiceImpl implements IOrganizationUnitService {\n    private _baseUrl: string = `http://localhost:8080/backend/v1/organization-unit`;\n    private _headers: Record<string, any> = {};\n    private _apiKey: string;\n\n    constructor(private _opts: IBackendClientOptions) {\n        if (typeof _opts.baseUrl === \"string\") {\n            this._baseUrl = `${_opts.baseUrl}/organization-unit`;\n        }\n        if (typeof _opts.headers === \"object\") {\n            this._headers = _opts.headers;\n        }\n        if (typeof _opts.apiKey !== \"string\") {\n            throw new Error(\n                `[OrganizationUnitService] An API key is required to use the Backend API`\n            );\n        }\n        this._apiKey = _opts.apiKey;\n        this._headers[\"Authorization\"] = `Bearer ${this._apiKey}`;\n    }\n\n    async listAll(\n        opts?: IBackendListingOptions<IOrganizationUnitSort>\n    ): Promise<Array<IOrganizationUnit>> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate opts\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            query: _listParams(opts),\n        });\n    }\n\n    async countAll(): Promise<number> {\n        // FIXME: Wrap for error handling\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: \"/count\",\n        });\n    }\n\n    async getById(id: string): Promise<IOrganizationUnit | null> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: `/${id}`,\n        });\n    }\n\n    async search(\n        filter: IOrganizationUnitFilter,\n        opts?: IBackendListingOptions<IOrganizationUnitSort>\n    ) {\n        // FIXME: Wrap for error handling\n        // TODO: Validate filter\n        // TODO: Validate opts\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: \"/search\",\n            query: _listParams(opts),\n            body: filter,\n        });\n    }\n\n    async countFor(filter: IOrganizationUnitFilter): Promise<number> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate filter\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: \"/search/count\",\n            body: filter,\n        });\n    }\n\n    async getEmployeesOf(id: string): Promise<Array<IEmployee>> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: `/${id}/employees`,\n        });\n    }\n\n    async create(\n        newOrganizationUnit: INewOrganizationUnit\n    ): Promise<IOrganizationUnit> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate payload\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            body: newOrganizationUnit,\n        });\n    }\n    async upsert(\n        newOrUpdatedEntities: Array<IOrganizationUnit>\n    ): Promise<Array<IOrganizationUnit>> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate payload\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PUT\",\n            body: newOrUpdatedEntities,\n        });\n    }\n    async fullUpdate(\n        id: string,\n        updatedOrganizationUnit: INewOrganizationUnit\n    ): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PUT\",\n            path: `/${id}`,\n            body: updatedOrganizationUnit,\n            noOp: true,\n        });\n    }\n    async partialUpdate(\n        id: string,\n        updatedFields: Partial<INewOrganizationUnit>\n    ): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PATCH\",\n            path: `/${id}`,\n            body: updatedFields,\n            noOp: true,\n        });\n    }\n    async updateName(id: string, name: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate name\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/name`,\n            body: name,\n            noOp: true,\n        });\n    }\n    async clearName(id: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"DELETE\",\n            path: `/${id}/name`,\n            noOp: true,\n        });\n    }\n    async remove(id: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"DELETE\",\n            path: `/${id}`,\n            noOp: true,\n        });\n    }\n}\n\nexport function createOrganizationUnitService(\n    opts: IBackendClientOptions\n): IOrganizationUnitService {\n    return new OrganizationUnitServiceImpl(opts);\n}\n\n/** An employee */\nexport interface IEmployee {\n    /** The unique identifier for this Employee */\n    id: string;\n\n    /** No description. */\n    firstName: string;\n\n    /** No description. */\n    lastName: string;\n\n    /** No description. */\n    birthDate: string;\n\n    /** No description. */\n    lastSeenAt: string;\n\n    /** Org unit of employee */\n    orgUnitId: string;\n}\n\n/** DTO for a new Employee */\nexport interface INewEmployee {\n    /** No description. */\n    firstName?: string | null;\n\n    /** No description. */\n    lastName?: string | null;\n\n    /** No description. */\n    birthDate?: string | null;\n\n    /** No description. */\n    lastSeenAt?: string | null;\n\n    /** Org unit of employee */\n    orgUnitId?: string | null;\n}\n\n/** DTO for filtering Employee objects */\nexport interface IEmployeeFilter {\n    and?: Array<IEmployeeFilter>;\n    or?: Array<IEmployeeFilter>;\n    not?: IEmployeeFilter;\n    firstName?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n        contains?: string;\n        notContains?: string;\n        startsWith?: string;\n        notStartsWith?: string;\n        endsWith?: string;\n        notEndsWith?: string;\n    };\n    lastName?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n        contains?: string;\n        notContains?: string;\n        startsWith?: string;\n        notStartsWith?: string;\n        endsWith?: string;\n        notEndsWith?: string;\n    };\n    birthDate?: {\n        equals?: string;\n        notEquals?: string;\n        greaterThan?: string;\n        lessThan?: string;\n        greaterThanOrEquals?: string;\n        lessThanOrEquals?: string;\n    };\n    lastSeenAt?: {\n        equals?: string;\n        notEquals?: string;\n        greaterThan?: string;\n        lessThan?: string;\n        greaterThanOrEquals?: string;\n        lessThanOrEquals?: string;\n    };\n    id?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n    };\n}\n\nexport type IEmployeeSort =\n    | \"id__asc\"\n    | \"id__desc\"\n    | \"firstName__asc\"\n    | \"firstName__desc\"\n    | \"lastName__asc\"\n    | \"lastName__desc\"\n    | \"birthDate__asc\"\n    | \"birthDate__desc\"\n    | \"lastSeenAt__asc\"\n    | \"lastSeenAt__desc\";\n\nexport interface IEmployeeService {\n    /**\n     * List all Employee objects, optionally applying paging and sorting.\n     * @param opts Options for paging and sorting\n     * @returns A list of Employee objects\n     */\n    listAll(\n        opts?: IBackendListingOptions<IEmployeeSort>\n    ): Promise<Array<IEmployee>>;\n\n    /**\n     * Get a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     * @returns The Employee object. Throws an error if not found.\n     */\n    getById(id: string): Promise<IEmployee>;\n\n    /**\n     * Count the total number of Employee objects.\n     * @returns The total number of Employee objects\n     */\n    countAll(): Promise<number>;\n\n    /**\n     * Search for Employee objects using a filter, optionally applying paging and sorting.\n     * @param filter The filter to apply\n     * @param opts Options for paging and sorting\n     * @returns A list of filtered Employee objects\n     */\n    search(\n        filter: IEmployeeFilter,\n        opts?: IBackendListingOptions<IEmployeeSort>\n    );\n\n    /**\n     * Count the total number of Employee objects that match a filter.\n     * @param filter The filter to apply\n     * @returns The total number of Employee objects that match the filter\n     */\n    countFor(filter: IEmployeeFilter): Promise<number>;\n\n    /**\n     * Get the Org Unit of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     * @returns The Org Unit of the given Employee object. Throws an error if the Employee object is not found.\n     */\n    getOrgUnitOf(id: string): Promise<IOrganizationUnit | null>;\n\n    /**\n     * Create a new Employee object.\n     * @param newEmployee The new Employee object to create\n     * @returns The newly created Employee object\n     */\n    create(newEmployee: INewEmployee): Promise<IEmployee>;\n\n    /**\n     * Create or update a list of Employee objects. Each object will either be created or updated.\n     * @param newOrUpdatedEntities The list of Employee objects to create or update\n     * @returns The list of newly created or updated Employee objects\n     */\n    upsert(newOrUpdatedEntities: Array<IEmployee>): Promise<Array<IEmployee>>;\n\n    /**\n     * Update a Employee object by its unique identifier. Requires a value for ALL FIELDS of the object. Nulls will be interpreted as clearing the field. Missing fields will be nulls.\n     * @param id The unique identifier of the Employee object\n     * @param updatedEmployee The updated Employee object\n     */\n    fullUpdate(id: string, updatedEmployee: INewEmployee): Promise<void>;\n\n    /**\n     * Update a Employee object by its unique identifier. Requires a value for at least one field of the object. Nulls and missing fields will be ignored.\n     * @param id The unique identifier of the Employee object\n     * @param updatedFields The fields to update\n     */\n    partialUpdate(\n        id: string,\n        updatedFields: Partial<INewEmployee>\n    ): Promise<void>;\n\n    /**\n     * Update the firstName field of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     * @param firstName The new value for the firstName field\n     */\n    updateFirstName(id: string, firstName: string): Promise<void>;\n\n    /**\n     * Update the lastName field of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     * @param lastName The new value for the lastName field\n     */\n    updateLastName(id: string, lastName: string): Promise<void>;\n\n    /**\n     * Update the birthDate field of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     * @param birthDate The new value for the birthDate field\n     */\n    updateBirthDate(id: string, birthDate: string): Promise<void>;\n\n    /**\n     * Update the lastSeenAt field of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     * @param lastSeenAt The new value for the lastSeenAt field\n     */\n    updateLastSeenAt(id: string, lastSeenAt: string): Promise<void>;\n\n    /**\n     * Clear the lastSeenAt field of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     */\n    clearLastSeenAt(id: string): Promise<void>;\n\n    /**\n     * Update the orgUnit of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     * @param orgUnit The new value for the orgUnit association\n     */\n    updateOrgUnit(id: string, orgUnit: string): Promise<void>;\n\n    /**\n     * Clear the orgUnit of a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     */\n    clearOrgUnit(id: string): Promise<void>;\n    /**\n     * Remove a Employee object by its unique identifier.\n     * @param id The unique identifier of the Employee object\n     */\n    remove(id: string): Promise<void>;\n}\n\nclass EmployeeServiceImpl implements IEmployeeService {\n    private _baseUrl: string = `http://localhost:8080/backend/v1/employee`;\n    private _headers: Record<string, any> = {};\n    private _apiKey: string;\n\n    constructor(private _opts: IBackendClientOptions) {\n        if (typeof _opts.baseUrl === \"string\") {\n            this._baseUrl = `${_opts.baseUrl}/employee`;\n        }\n        if (typeof _opts.headers === \"object\") {\n            this._headers = _opts.headers;\n        }\n        if (typeof _opts.apiKey !== \"string\") {\n            throw new Error(\n                `[EmployeeService] An API key is required to use the Backend API`\n            );\n        }\n        this._apiKey = _opts.apiKey;\n        this._headers[\"Authorization\"] = `Bearer ${this._apiKey}`;\n    }\n\n    async listAll(\n        opts?: IBackendListingOptions<IEmployeeSort>\n    ): Promise<Array<IEmployee>> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate opts\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            query: _listParams(opts),\n        });\n    }\n\n    async countAll(): Promise<number> {\n        // FIXME: Wrap for error handling\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: \"/count\",\n        });\n    }\n\n    async getById(id: string): Promise<IEmployee | null> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: `/${id}`,\n        });\n    }\n\n    async search(\n        filter: IEmployeeFilter,\n        opts?: IBackendListingOptions<IEmployeeSort>\n    ) {\n        // FIXME: Wrap for error handling\n        // TODO: Validate filter\n        // TODO: Validate opts\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: \"/search\",\n            query: _listParams(opts),\n            body: filter,\n        });\n    }\n\n    async countFor(filter: IEmployeeFilter): Promise<number> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate filter\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: \"/search/count\",\n            body: filter,\n        });\n    }\n\n    async getOrgUnitOf(id: string): Promise<IOrganizationUnit | null> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: `/${id}/org-unit`,\n        });\n    }\n\n    async create(newEmployee: INewEmployee): Promise<IEmployee> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate payload\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            body: newEmployee,\n        });\n    }\n    async upsert(\n        newOrUpdatedEntities: Array<IEmployee>\n    ): Promise<Array<IEmployee>> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate payload\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PUT\",\n            body: newOrUpdatedEntities,\n        });\n    }\n    async fullUpdate(id: string, updatedEmployee: INewEmployee): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PUT\",\n            path: `/${id}`,\n            body: updatedEmployee,\n            noOp: true,\n        });\n    }\n    async partialUpdate(\n        id: string,\n        updatedFields: Partial<INewEmployee>\n    ): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PATCH\",\n            path: `/${id}`,\n            body: updatedFields,\n            noOp: true,\n        });\n    }\n    async updateFirstName(id: string, firstName: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate firstName\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/first-name`,\n            body: firstName,\n            noOp: true,\n        });\n    }\n    async updateLastName(id: string, lastName: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate lastName\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/last-name`,\n            body: lastName,\n            noOp: true,\n        });\n    }\n    async updateBirthDate(id: string, birthDate: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate birthDate\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/birth-date`,\n            body: birthDate,\n            noOp: true,\n        });\n    }\n    async updateLastSeenAt(id: string, lastSeenAt: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate lastSeenAt\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/last-seen-at`,\n            body: lastSeenAt,\n            noOp: true,\n        });\n    }\n    async clearLastSeenAt(id: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"DELETE\",\n            path: `/${id}/last-seen-at`,\n            noOp: true,\n        });\n    }\n    async updateOrgUnit(id: string, orgUnit: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate orgUnit ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/org-unit`,\n            body: orgUnit,\n            noOp: true,\n        });\n    }\n    async clearOrgUnit(id: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"DELETE\",\n            path: `/${id}/org-unit`,\n            noOp: true,\n        });\n    }\n    async remove(id: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"DELETE\",\n            path: `/${id}`,\n            noOp: true,\n        });\n    }\n}\n\nexport function createEmployeeService(\n    opts: IBackendClientOptions\n): IEmployeeService {\n    return new EmployeeServiceImpl(opts);\n}\n\n/** No description. */\nexport interface IShift {\n    /** The unique identifier for this Shift */\n    id: string;\n\n    /** No description. */\n    beginsAt: string;\n\n    /** No description. */\n    endsAt: string;\n}\n\n/** DTO for a new Shift */\nexport interface INewShift {\n    /** No description. */\n    beginsAt?: string | null;\n\n    /** No description. */\n    endsAt?: string | null;\n}\n\n/** DTO for filtering Shift objects */\nexport interface IShiftFilter {\n    and?: Array<IShiftFilter>;\n    or?: Array<IShiftFilter>;\n    not?: IShiftFilter;\n    beginsAt?: {\n        equals?: string;\n        notEquals?: string;\n        greaterThan?: string;\n        lessThan?: string;\n        greaterThanOrEquals?: string;\n        lessThanOrEquals?: string;\n    };\n    endsAt?: {\n        equals?: string;\n        notEquals?: string;\n        greaterThan?: string;\n        lessThan?: string;\n        greaterThanOrEquals?: string;\n        lessThanOrEquals?: string;\n    };\n    id?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n    };\n}\n\nexport type IShiftSort =\n    | \"id__asc\"\n    | \"id__desc\"\n    | \"beginsAt__asc\"\n    | \"beginsAt__desc\"\n    | \"endsAt__asc\"\n    | \"endsAt__desc\";\n\nexport interface IShiftService {\n    /**\n     * List all Shift objects, optionally applying paging and sorting.\n     * @param opts Options for paging and sorting\n     * @returns A list of Shift objects\n     */\n    listAll(opts?: IBackendListingOptions<IShiftSort>): Promise<Array<IShift>>;\n\n    /**\n     * Get a Shift object by its unique identifier.\n     * @param id The unique identifier of the Shift object\n     * @returns The Shift object. Throws an error if not found.\n     */\n    getById(id: string): Promise<IShift>;\n\n    /**\n     * Count the total number of Shift objects.\n     * @returns The total number of Shift objects\n     */\n    countAll(): Promise<number>;\n\n    /**\n     * Search for Shift objects using a filter, optionally applying paging and sorting.\n     * @param filter The filter to apply\n     * @param opts Options for paging and sorting\n     * @returns A list of filtered Shift objects\n     */\n    search(filter: IShiftFilter, opts?: IBackendListingOptions<IShiftSort>);\n\n    /**\n     * Count the total number of Shift objects that match a filter.\n     * @param filter The filter to apply\n     * @returns The total number of Shift objects that match the filter\n     */\n    countFor(filter: IShiftFilter): Promise<number>;\n\n    /**\n     * Create a new Shift object.\n     * @param newShift The new Shift object to create\n     * @returns The newly created Shift object\n     */\n    create(newShift: INewShift): Promise<IShift>;\n\n    /**\n     * Create or update a list of Shift objects. Each object will either be created or updated.\n     * @param newOrUpdatedEntities The list of Shift objects to create or update\n     * @returns The list of newly created or updated Shift objects\n     */\n    upsert(newOrUpdatedEntities: Array<IShift>): Promise<Array<IShift>>;\n\n    /**\n     * Update a Shift object by its unique identifier. Requires a value for ALL FIELDS of the object. Nulls will be interpreted as clearing the field. Missing fields will be nulls.\n     * @param id The unique identifier of the Shift object\n     * @param updatedShift The updated Shift object\n     */\n    fullUpdate(id: string, updatedShift: INewShift): Promise<void>;\n\n    /**\n     * Update a Shift object by its unique identifier. Requires a value for at least one field of the object. Nulls and missing fields will be ignored.\n     * @param id The unique identifier of the Shift object\n     * @param updatedFields The fields to update\n     */\n    partialUpdate(id: string, updatedFields: Partial<INewShift>): Promise<void>;\n\n    /**\n     * Update the beginsAt field of a Shift object by its unique identifier.\n     * @param id The unique identifier of the Shift object\n     * @param beginsAt The new value for the beginsAt field\n     */\n    updateBeginsAt(id: string, beginsAt: string): Promise<void>;\n\n    /**\n     * Update the endsAt field of a Shift object by its unique identifier.\n     * @param id The unique identifier of the Shift object\n     * @param endsAt The new value for the endsAt field\n     */\n    updateEndsAt(id: string, endsAt: string): Promise<void>;\n\n    /**\n     * Remove a Shift object by its unique identifier.\n     * @param id The unique identifier of the Shift object\n     */\n    remove(id: string): Promise<void>;\n}\n\nclass ShiftServiceImpl implements IShiftService {\n    private _baseUrl: string = `http://localhost:8080/backend/v1/shift`;\n    private _headers: Record<string, any> = {};\n    private _apiKey: string;\n\n    constructor(private _opts: IBackendClientOptions) {\n        if (typeof _opts.baseUrl === \"string\") {\n            this._baseUrl = `${_opts.baseUrl}/shift`;\n        }\n        if (typeof _opts.headers === \"object\") {\n            this._headers = _opts.headers;\n        }\n        if (typeof _opts.apiKey !== \"string\") {\n            throw new Error(\n                `[ShiftService] An API key is required to use the Backend API`\n            );\n        }\n        this._apiKey = _opts.apiKey;\n        this._headers[\"Authorization\"] = `Bearer ${this._apiKey}`;\n    }\n\n    async listAll(\n        opts?: IBackendListingOptions<IShiftSort>\n    ): Promise<Array<IShift>> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate opts\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            query: _listParams(opts),\n        });\n    }\n\n    async countAll(): Promise<number> {\n        // FIXME: Wrap for error handling\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: \"/count\",\n        });\n    }\n\n    async getById(id: string): Promise<IShift | null> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"GET\",\n            path: `/${id}`,\n        });\n    }\n\n    async search(\n        filter: IShiftFilter,\n        opts?: IBackendListingOptions<IShiftSort>\n    ) {\n        // FIXME: Wrap for error handling\n        // TODO: Validate filter\n        // TODO: Validate opts\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: \"/search\",\n            query: _listParams(opts),\n            body: filter,\n        });\n    }\n\n    async countFor(filter: IShiftFilter): Promise<number> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate filter\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: \"/search/count\",\n            body: filter,\n        });\n    }\n\n    async create(newShift: INewShift): Promise<IShift> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate payload\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            body: newShift,\n        });\n    }\n    async upsert(newOrUpdatedEntities: Array<IShift>): Promise<Array<IShift>> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate payload\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PUT\",\n            body: newOrUpdatedEntities,\n        });\n    }\n    async fullUpdate(id: string, updatedShift: INewShift): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PUT\",\n            path: `/${id}`,\n            body: updatedShift,\n            noOp: true,\n        });\n    }\n    async partialUpdate(\n        id: string,\n        updatedFields: Partial<INewShift>\n    ): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"PATCH\",\n            path: `/${id}`,\n            body: updatedFields,\n            noOp: true,\n        });\n    }\n    async updateBeginsAt(id: string, beginsAt: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate beginsAt\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/begins-at`,\n            body: beginsAt,\n            noOp: true,\n        });\n    }\n    async updateEndsAt(id: string, endsAt: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        // TODO: Validate endsAt\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"POST\",\n            path: `/${id}/ends-at`,\n            body: endsAt,\n            noOp: true,\n        });\n    }\n    async remove(id: string): Promise<void> {\n        // FIXME: Wrap for error handling\n        // TODO: Validate ID\n        return await _makeRequest(this._baseUrl, this._headers, {\n            method: \"DELETE\",\n            path: `/${id}`,\n            noOp: true,\n        });\n    }\n}\n\nexport function createShiftService(opts: IBackendClientOptions): IShiftService {\n    return new ShiftServiceImpl(opts);\n}\n\nexport interface IBackendService {\n    readonly organizationUnit: IOrganizationUnitService;\n    readonly employee: IEmployeeService;\n    readonly shift: IShiftService;\n}\n\nclass BackendServiceImpl implements IBackendService {\n    readonly organizationUnit: IOrganizationUnitService;\n    readonly employee: IEmployeeService;\n    readonly shift: IShiftService;\n\n    constructor(private _opts: IBackendClientOptions) {\n        this.organizationUnit = createOrganizationUnitService(_opts);\n        this.employee = createEmployeeService(_opts);\n        this.shift = createShiftService(_opts);\n    }\n}\n\nexport function createBackendService(\n    opts: IBackendClientOptions\n): IBackendService {\n    return new BackendServiceImpl(opts);\n}\n\nexport interface IBackendUserDetails {\n    /**\n     * ID of the user\n     */\n    id: string;\n    /**\n     * The user's login name\n     */\n    loginName: string;\n    /**\n     * The user's display name\n     */\n    displayName: string;\n}\n\nexport interface IBackendLoginResult {\n    /**\n     * The user ID of the logged in user\n     */\n    userId: string;\n    /**\n     * Details about the logged in user\n     */\n    userDetails: IBackendUserDetails;\n    /**\n     * Options to pass to the client services to make them authenticated with the logged in user\n     */\n    clientOptions: IBackendClientOptions;\n}\n\nexport interface IBackendAuthService {\n    /**\n     * Log in to the Backend API using a login name and password.\n     * @param loginName The login name to log in with\n     * @param password The password to log in with\n     * @returns The result of the login, including the user ID, user details, and client options\n     */\n    login(loginName: string, password: string): Promise<IBackendLoginResult>;\n}\n\nclass BackendAuthServiceImpl implements IBackendAuthService {\n    constructor(\n        private _baseUrl: string = `http://localhost:8080/backend/v1`\n    ) {}\n\n    async login(\n        loginName: string,\n        password: string\n    ): Promise<IBackendLoginResult> {\n        const token = await _makeRequest(\n            this._baseUrl,\n            {},\n            {\n                method: \"POST\",\n                path: \"/auth/login\",\n                body: { loginName, password },\n                asText: true,\n            }\n        );\n        const authenticatedHeaders = { Authorization: `Bearer ${token}` };\n        const userDetails = await _makeRequest(\n            this._baseUrl,\n            authenticatedHeaders,\n            { method: \"GET\", path: \"/auth/me\" }\n        );\n        return {\n            userId: userDetails.id,\n            userDetails,\n            clientOptions: {\n                baseUrl: this._baseUrl,\n                headers: authenticatedHeaders,\n                apiKey: token,\n            },\n        };\n    }\n}\n\nexport function createBackendAuthService(\n    baseUrl: string = `http://localhost:8080/backend/v1`\n): IBackendAuthService {\n    return new BackendAuthServiceImpl(baseUrl);\n}\n",
      "contentHash": "f8d22c5ba784cb834529d54ba040cd23fe96dd291d7acd185018c5f874b4e60e",
      "noWriteIfExists": false
    },
    {
      "filename": "test/index.test.js",
      "content": "const client = require(\"../lib/index\");\nconst { expect } = require(\"chai\");\n\nfunction randomString(length = 10) {\n    return Math.random()\n        .toString(36)\n        .substring(2, 2 + length);\n}\n\nfunction randomInteger(min = 0, max = 100000) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction randomBoolean() {\n    return Math.random() >= 0.5;\n}\n\nfunction randomFloat(min = 0, max = 1000) {\n    return Math.random() * (max - min) + min;\n}\n\nfunction randomDouble(min = 0, max = 1000) {\n    return Math.random() * (max - min) + min;\n}\n\nfunction randomLocalTime() {\n    let randomHour = randomInteger(0, 23);\n    let randomMinute = randomInteger(0, 59);\n    let randomSecond = randomInteger(0, 59);\n    return `${randomHour < 10 ? \"0\" : \"\"}${randomHour}:${\n        randomMinute < 10 ? \"0\" : \"\"\n    }${randomMinute}:${randomSecond < 10 ? \"0\" : \"\"}${randomSecond}`;\n}\n\nfunction randomLocalDate() {\n    const oneYearMs = 1000 * 60 * 60 * 24 * 365;\n    const randomMs = 2 * Math.floor(Math.random() * oneYearMs) - oneYearMs;\n    const randomDate = new Date(Date.now() + randomMs);\n    return randomDate.toISOString().split(\"T\")[0];\n}\n\nfunction randomInstant() {\n    return `${randomLocalDate()}T${randomLocalTime()}Z`;\n}\n\ndescribe(\"Client Tests\", () => {\n    const backendUrl =\n        process.env.CLIENT_TEST_BACKEND_URL ||\n        `http://localhost:8080/backend/v1`;\n    const authLoginName = process.env.CLIENT_TEST_AUTH_LOGIN_NAME || \"admin\";\n    const authLoginPassword =\n        process.env.CLIENT_TEST_AUTH_LOGIN_PASSWORD || \"admin\";\n    const authJwtToken = process.env.CLIENT_TEST_AUTH_JWT_TOKEN || null;\n\n    describe(\"Organization Unit Service Tests (http://localhost:8080/backend/v1/organization-unit)\", () => {\n        var clientOpts = null;\n\n        const prepareClientOpts = async () => {\n            if (clientOpts) {\n                return;\n            }\n\n            if (!authLoginName || !authLoginPassword) {\n                throw new Error(\n                    \"Cannot run tests: missing login credentials in test configuration (CLIENT_TEST_AUTH_LOGIN_NAME and CLIENT_TEST_AUTH_LOGIN_PASSWORD variables)\"\n                );\n            }\n            const authSvc = client.createBackendAuthService(backendUrl);\n            const { clientOptions } = await authSvc.login(\n                authLoginName,\n                authLoginPassword\n            );\n            clientOpts = clientOptions;\n        };\n\n        const createService = async () => {\n            await prepareClientOpts();\n            return client.createOrganizationUnitService(clientOpts);\n        };\n\n        it(\"GET / (no opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll();\n            expect(list).to.be.an(\"array\");\n        });\n\n        it(\"GET / (with opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll({\n                offset: 10,\n                limit: 10,\n                sort: \"id__desc\",\n            });\n            expect(list).to.be.an(\"array\");\n            expect(list.length).to.be.lessThanOrEqual(10);\n        });\n\n        it(\"GET /count\", async () => {\n            const service = await createService();\n            const count = await service.countAll();\n            expect(count).to.be.greaterThanOrEqual(0);\n        });\n\n        // New test: Create a new entity with random attributes and null associations\n        it(\"POST / - create new Organization Unit with null associations\", async () => {\n            const service = await createService();\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            expect(createdOrganizationUnit).to.be.an(\"object\");\n            expect(createdOrganizationUnit).to.have.property(\"id\");\n            expect(createdOrganizationUnit).to.have.property(\n                \"name\",\n                newOrganizationUnit.name\n            );\n        });\n\n        it(\"GET /:id\", async () => {\n            const service = await createService();\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            const retrievedOrganizationUnit = await service.getById(id);\n            expect(retrievedOrganizationUnit).to.be.an(\"object\");\n            expect(retrievedOrganizationUnit).to.have.property(\"id\", id);\n        });\n\n        // New test: Create a new entity with random attributes and non-null associations\n        it(\"POST / - create new Organization Unit with non-null associations\", async () => {\n            const service = await createService();\n\n            // Create related entities for associations\n            const associations = {};\n\n            const newOrganizationUnit = {\n                name: randomString(),\n                ...associations,\n            };\n\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            expect(createdOrganizationUnit).to.be.an(\"object\");\n            expect(createdOrganizationUnit).to.have.property(\"id\");\n            expect(createdOrganizationUnit).to.have.property(\n                \"name\",\n                newOrganizationUnit.name\n            );\n        });\n\n        // New test: Update an attribute with a random value\n        it(\"POST /:id/name - update attribute name\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            // Update the attribute\n            const updatedValue = randomString();\n            await service.updateName(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedOrganizationUnit = await service.getById(id);\n            expect(updatedOrganizationUnit).to.have.property(\n                \"name\",\n                updatedValue\n            );\n        });\n\n        // New test: Clear an attribute\n        it(\"DELETE /:id/name - clear attribute name\", async () => {\n            const service = await createService();\n            // Create a new entity with the attribute set\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            // Clear the attribute\n            await service.clearName(id); // Returns Promise<void>\n            // Retrieve and verify the attribute is cleared\n            const updatedOrganizationUnit = await service.getById(id);\n            expect(updatedOrganizationUnit).to.have.property(\"name\").that.is\n                .null;\n        });\n\n        // New test: Update an association with null and non-null values\n\n        // New test: Delete an entity\n        it(\"DELETE /:id - remove Organization Unit\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            // Delete the entity\n            await service.remove(id);\n            // Verify the entity has been deleted\n            let error = null;\n            try {\n                await service.getById(id);\n            } catch (err) {\n                error = err;\n            }\n            expect(error).to.not.be.null;\n        });\n\n        // New test: Search entities\n        it(\"POST /search - search Organization Unit entities\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            // Search for the entity using the unique attribute\n            const filter = {\n                and: [\n                    {\n                        id: {\n                            in: [createdOrganizationUnit.id],\n                        },\n                    },\n                    {\n                        id: {\n                            notIn: [uniqueValue],\n                        },\n                    },\n                ],\n            };\n            const results = await service.search(filter);\n            expect(results).to.be.an(\"array\");\n            const found = results.some(\n                (e) => e.id === createdOrganizationUnit.id\n            );\n            expect(found).to.be.true;\n        });\n\n        // New test: Count entities matching a filter\n        it(\"POST /search/count - count Organization Unit entities matching a filter\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            // Count entities matching the filter\n            const filter = {\n                and: [\n                    {\n                        id: {\n                            in: [createdOrganizationUnit.id],\n                        },\n                    },\n                    {\n                        id: {\n                            notIn: [uniqueValue],\n                        },\n                    },\n                ],\n            };\n            const count = await service.countFor(filter);\n            expect(count).to.be.a(\"number\");\n            expect(count).to.be.greaterThanOrEqual(1);\n        });\n    });\n    describe(\"Employee Service Tests (http://localhost:8080/backend/v1/employee)\", () => {\n        var clientOpts = null;\n\n        const prepareClientOpts = async () => {\n            if (clientOpts) {\n                return;\n            }\n\n            if (!authLoginName || !authLoginPassword) {\n                throw new Error(\n                    \"Cannot run tests: missing login credentials in test configuration (CLIENT_TEST_AUTH_LOGIN_NAME and CLIENT_TEST_AUTH_LOGIN_PASSWORD variables)\"\n                );\n            }\n            const authSvc = client.createBackendAuthService(backendUrl);\n            const { clientOptions } = await authSvc.login(\n                authLoginName,\n                authLoginPassword\n            );\n            clientOpts = clientOptions;\n        };\n\n        const createService = async () => {\n            await prepareClientOpts();\n            return client.createEmployeeService(clientOpts);\n        };\n\n        it(\"GET / (no opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll();\n            expect(list).to.be.an(\"array\");\n        });\n\n        it(\"GET / (with opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll({\n                offset: 10,\n                limit: 10,\n                sort: \"id__desc\",\n            });\n            expect(list).to.be.an(\"array\");\n            expect(list.length).to.be.lessThanOrEqual(10);\n        });\n\n        it(\"GET /count\", async () => {\n            const service = await createService();\n            const count = await service.countAll();\n            expect(count).to.be.greaterThanOrEqual(0);\n        });\n\n        // New test: Create a new entity with random attributes and null associations\n        it(\"POST / - create new Employee with null associations\", async () => {\n            const service = await createService();\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnit: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            expect(createdEmployee).to.be.an(\"object\");\n            expect(createdEmployee).to.have.property(\"id\");\n            expect(createdEmployee).to.have.property(\n                \"firstName\",\n                newEmployee.firstName\n            );\n            expect(createdEmployee).to.have.property(\n                \"lastName\",\n                newEmployee.lastName\n            );\n            expect(createdEmployee).to.have.property(\n                \"birthDate\",\n                newEmployee.birthDate\n            );\n            expect(createdEmployee).to.have.property(\n                \"lastSeenAt\",\n                newEmployee.lastSeenAt\n            );\n        });\n\n        it(\"GET /:id\", async () => {\n            const service = await createService();\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnit: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            const retrievedEmployee = await service.getById(id);\n            expect(retrievedEmployee).to.be.an(\"object\");\n            expect(retrievedEmployee).to.have.property(\"id\", id);\n        });\n\n        // New test: Create a new entity with random attributes and non-null associations\n        it(\"POST / - create new Employee with non-null associations\", async () => {\n            const service = await createService();\n\n            // Create related entities for associations\n            const associations = {};\n            // Assuming the associated entity is OrganizationUnit\n            const relatedOrgUnitService =\n                await client.createOrganizationUnitService(clientOpts);\n            const relatedOrgUnit = await relatedOrgUnitService.create({\n                name: randomString(),\n            });\n            associations[\"orgUnitId\"] = relatedOrgUnit.id;\n\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                ...associations,\n            };\n\n            const createdEmployee = await service.create(newEmployee);\n            expect(createdEmployee).to.be.an(\"object\");\n            expect(createdEmployee).to.have.property(\"id\");\n            expect(createdEmployee).to.have.property(\n                \"firstName\",\n                newEmployee.firstName\n            );\n            expect(createdEmployee).to.have.property(\n                \"lastName\",\n                newEmployee.lastName\n            );\n            expect(createdEmployee).to.have.property(\n                \"birthDate\",\n                newEmployee.birthDate\n            );\n            expect(createdEmployee).to.have.property(\n                \"lastSeenAt\",\n                newEmployee.lastSeenAt\n            );\n            expect(createdEmployee).to.have.property(\n                \"orgUnitId\",\n                associations[\"orgUnitId\"]\n            );\n        });\n\n        // New test: Update an attribute with a random value\n        it(\"POST /:id/firstName - update attribute firstName\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the attribute\n            const updatedValue = randomString();\n            await service.updateFirstName(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"firstName\", updatedValue);\n        });\n        it(\"POST /:id/lastName - update attribute lastName\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the attribute\n            const updatedValue = randomString();\n            await service.updateLastName(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"lastName\", updatedValue);\n        });\n        it(\"POST /:id/birthDate - update attribute birthDate\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the attribute\n            const updatedValue = randomLocalDate();\n            await service.updateBirthDate(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"birthDate\", updatedValue);\n        });\n        it(\"POST /:id/lastSeenAt - update attribute lastSeenAt\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the attribute\n            const updatedValue = randomInstant();\n            await service.updateLastSeenAt(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\n                \"lastSeenAt\",\n                updatedValue\n            );\n        });\n\n        // New test: Clear an attribute\n        it(\"DELETE /:id/lastSeenAt - clear attribute lastSeenAt\", async () => {\n            const service = await createService();\n            // Create a new entity with the attribute set\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Clear the attribute\n            await service.clearLastSeenAt(id); // Returns Promise<void>\n            // Retrieve and verify the attribute is cleared\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"lastSeenAt\").that.is.null;\n        });\n\n        // New test: Update an association with null and non-null values\n        it(\"POST /:id/orgUnit - update association orgUnit with non-null value\", async () => {\n            const service = await createService();\n            // Create related entity\n            const relatedOrgUnitService =\n                await client.createOrganizationUnitService(clientOpts);\n            const relatedOrgUnit = await relatedOrgUnitService.create({\n                name: randomString(),\n            });\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the association\n            await service.updateOrgUnit(id, relatedOrgUnit.id); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\n                \"orgUnitId\",\n                relatedOrgUnit.id\n            );\n        });\n\n        it(\"DELETE /:id/orgUnit - clear association orgUnit\", async () => {\n            const service = await createService();\n            // Create related entity\n            const relatedOrgUnitService =\n                await client.createOrganizationUnitService(clientOpts);\n            const relatedOrgUnit = await relatedOrgUnitService.create({\n                name: randomString(),\n            });\n            // Create a new entity with the association set\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: relatedOrgUnit.id,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Clear the association\n            await service.clearOrgUnit(id); // Returns Promise<void>\n            // Retrieve and verify the association is cleared\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee[\"orgUnitId\"]).to.be.null;\n        });\n\n        // New test: Delete an entity\n        it(\"DELETE /:id - remove Employee\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Delete the entity\n            await service.remove(id);\n            // Verify the entity has been deleted\n            let error = null;\n            try {\n                await service.getById(id);\n            } catch (err) {\n                error = err;\n            }\n            expect(error).to.not.be.null;\n        });\n\n        // New test: Search entities\n        it(\"POST /search - search Employee entities\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            // Search for the entity using the unique attribute\n            const filter = {\n                and: [\n                    {\n                        id: {\n                            in: [createdEmployee.id],\n                        },\n                    },\n                    {\n                        id: {\n                            notIn: [uniqueValue],\n                        },\n                    },\n                ],\n            };\n            const results = await service.search(filter);\n            expect(results).to.be.an(\"array\");\n            const found = results.some((e) => e.id === createdEmployee.id);\n            expect(found).to.be.true;\n        });\n\n        // New test: Count entities matching a filter\n        it(\"POST /search/count - count Employee entities matching a filter\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                birthDate: randomLocalDate(),\n                lastSeenAt: randomInstant(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            // Count entities matching the filter\n            const filter = {\n                and: [\n                    {\n                        id: {\n                            in: [createdEmployee.id],\n                        },\n                    },\n                    {\n                        id: {\n                            notIn: [uniqueValue],\n                        },\n                    },\n                ],\n            };\n            const count = await service.countFor(filter);\n            expect(count).to.be.a(\"number\");\n            expect(count).to.be.greaterThanOrEqual(1);\n        });\n    });\n    describe(\"Shift Service Tests (http://localhost:8080/backend/v1/shift)\", () => {\n        var clientOpts = null;\n\n        const prepareClientOpts = async () => {\n            if (clientOpts) {\n                return;\n            }\n\n            if (!authLoginName || !authLoginPassword) {\n                throw new Error(\n                    \"Cannot run tests: missing login credentials in test configuration (CLIENT_TEST_AUTH_LOGIN_NAME and CLIENT_TEST_AUTH_LOGIN_PASSWORD variables)\"\n                );\n            }\n            const authSvc = client.createBackendAuthService(backendUrl);\n            const { clientOptions } = await authSvc.login(\n                authLoginName,\n                authLoginPassword\n            );\n            clientOpts = clientOptions;\n        };\n\n        const createService = async () => {\n            await prepareClientOpts();\n            return client.createShiftService(clientOpts);\n        };\n\n        it(\"GET / (no opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll();\n            expect(list).to.be.an(\"array\");\n        });\n\n        it(\"GET / (with opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll({\n                offset: 10,\n                limit: 10,\n                sort: \"id__desc\",\n            });\n            expect(list).to.be.an(\"array\");\n            expect(list.length).to.be.lessThanOrEqual(10);\n        });\n\n        it(\"GET /count\", async () => {\n            const service = await createService();\n            const count = await service.countAll();\n            expect(count).to.be.greaterThanOrEqual(0);\n        });\n\n        // New test: Create a new entity with random attributes and null associations\n        it(\"POST / - create new Shift with null associations\", async () => {\n            const service = await createService();\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n            };\n            const createdShift = await service.create(newShift);\n            expect(createdShift).to.be.an(\"object\");\n            expect(createdShift).to.have.property(\"id\");\n            expect(createdShift).to.have.property(\n                \"beginsAt\",\n                newShift.beginsAt\n            );\n            expect(createdShift).to.have.property(\"endsAt\", newShift.endsAt);\n        });\n\n        it(\"GET /:id\", async () => {\n            const service = await createService();\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n            };\n            const createdShift = await service.create(newShift);\n            const id = createdShift.id;\n            const retrievedShift = await service.getById(id);\n            expect(retrievedShift).to.be.an(\"object\");\n            expect(retrievedShift).to.have.property(\"id\", id);\n        });\n\n        // New test: Create a new entity with random attributes and non-null associations\n        it(\"POST / - create new Shift with non-null associations\", async () => {\n            const service = await createService();\n\n            // Create related entities for associations\n            const associations = {};\n\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n                ...associations,\n            };\n\n            const createdShift = await service.create(newShift);\n            expect(createdShift).to.be.an(\"object\");\n            expect(createdShift).to.have.property(\"id\");\n            expect(createdShift).to.have.property(\n                \"beginsAt\",\n                newShift.beginsAt\n            );\n            expect(createdShift).to.have.property(\"endsAt\", newShift.endsAt);\n        });\n\n        // New test: Update an attribute with a random value\n        it(\"POST /:id/beginsAt - update attribute beginsAt\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n            };\n            const createdShift = await service.create(newShift);\n            const id = createdShift.id;\n            // Update the attribute\n            const updatedValue = randomLocalTime();\n            await service.updateBeginsAt(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedShift = await service.getById(id);\n            expect(updatedShift).to.have.property(\"beginsAt\", updatedValue);\n        });\n        it(\"POST /:id/endsAt - update attribute endsAt\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n            };\n            const createdShift = await service.create(newShift);\n            const id = createdShift.id;\n            // Update the attribute\n            const updatedValue = randomLocalTime();\n            await service.updateEndsAt(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedShift = await service.getById(id);\n            expect(updatedShift).to.have.property(\"endsAt\", updatedValue);\n        });\n\n        // New test: Clear an attribute\n\n        // New test: Update an association with null and non-null values\n\n        // New test: Delete an entity\n        it(\"DELETE /:id - remove Shift\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n            };\n            const createdShift = await service.create(newShift);\n            const id = createdShift.id;\n            // Delete the entity\n            await service.remove(id);\n            // Verify the entity has been deleted\n            let error = null;\n            try {\n                await service.getById(id);\n            } catch (err) {\n                error = err;\n            }\n            expect(error).to.not.be.null;\n        });\n\n        // New test: Search entities\n        it(\"POST /search - search Shift entities\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n            };\n            const createdShift = await service.create(newShift);\n            // Search for the entity using the unique attribute\n            const filter = {\n                and: [\n                    {\n                        id: {\n                            in: [createdShift.id],\n                        },\n                    },\n                    {\n                        id: {\n                            notIn: [uniqueValue],\n                        },\n                    },\n                ],\n            };\n            const results = await service.search(filter);\n            expect(results).to.be.an(\"array\");\n            const found = results.some((e) => e.id === createdShift.id);\n            expect(found).to.be.true;\n        });\n\n        // New test: Count entities matching a filter\n        it(\"POST /search/count - count Shift entities matching a filter\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newShift = {\n                beginsAt: randomLocalTime(),\n                endsAt: randomLocalTime(),\n            };\n            const createdShift = await service.create(newShift);\n            // Count entities matching the filter\n            const filter = {\n                and: [\n                    {\n                        id: {\n                            in: [createdShift.id],\n                        },\n                    },\n                    {\n                        id: {\n                            notIn: [uniqueValue],\n                        },\n                    },\n                ],\n            };\n            const count = await service.countFor(filter);\n            expect(count).to.be.a(\"number\");\n            expect(count).to.be.greaterThanOrEqual(1);\n        });\n    });\n});\n",
      "contentHash": "c9bd4049ed57de9df9bff297e79152a2757c231cf62a4f879f3c5ca53c3b7108",
      "noWriteIfExists": false
    },
    {
      "filename": "tsconfig.json",
      "content": "{\n    \"compilerOptions\": {\n        \"target\": \"ES2015\",\n        \"module\": \"CommonJS\",\n        \"moduleResolution\": \"Node\",\n        \"esModuleInterop\": true,\n        \"skipLibCheck\": true,\n        \"allowSyntheticDefaultImports\": true,\n        \"outDir\": \"lib\",\n        \"declaration\": true,\n        \"declarationDir\": \"types\",\n        \"sourceMap\": true,\n        \"declarationMap\": true\n    },\n    \"include\": [\"src/**/*.ts\"],\n    \"exclude\": [\"node_modules\"]\n}\n",
      "contentHash": "1f26459f4c4bb11cddbb260e6f02cb44196b31966aef4eeebcab1af5e3b44688",
      "noWriteIfExists": false
    }
  ]
}