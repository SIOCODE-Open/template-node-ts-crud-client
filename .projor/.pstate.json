{
  "generatedSource": [
    {
      "filename": ".gitignore",
      "content": "# Gitignore for Gradle and Java\n\nHELP.md\n.gradle\nbuild/\n!gradle/wrapper/gradle-wrapper.jar\n!**/src/main/**/build/\n!**/src/test/**/build/\n\n### STS ###\n.apt_generated\n.classpath\n.factorypath\n.project\n.settings\n.springBeans\n.sts4-cache\nbin/\n!**/src/main/**/bin/\n!**/src/test/**/bin/\n\n### IntelliJ IDEA ###\n.idea\n*.iws\n*.iml\n*.ipr\nout/\n!**/src/main/**/out/\n!**/src/test/**/out/\n\n### NetBeans ###\n/nbproject/private/\n/nbbuild/\n/dist/\n/nbdist/\n/.nb-gradle/\n\n### VS Code ###\n.vscode/\n\n# Git ignore for NPM\n\nnode_modules/",
      "contentHash": "fe42bbf3faec049820910b5b4f9a337b6dc6445443aed51c0c3021208e27f384",
      "noWriteIfExists": false
    },
    {
      "filename": "ENTITIES.md",
      "content": "# Organization Unit\n\nNo description.\n\n_Attributes_\n\n* Name : `String` - No description.\n\n\n\n_Reverse Associations_\n\n* Employees : `[]Employee` (mapped by `Employee :: Org Unit`) - Employees in the org unit\n\n\n# Employee\n\nAn employee\n\n_Attributes_\n\n* First Name : `String` - No description.\n* Last Name : `String` - No description.\n\n\n_Associations_\n\n* Org Unit : `Organization Unit` - Org unit of employee\n\n\n\n",
      "contentHash": "e860548d305d534a416a4679fb82d069ea5015026b0c02167ed89b84b377d080",
      "noWriteIfExists": false
    },
    {
      "filename": "package.json",
      "content": "{\n    \"name\": \"@example/backend-client-node\",\n    \"version\": \"0.0.1\",\n    \"private\": true,\n    \"description\": \"_You can edit this description in [`.projor/project.pglobal.yaml`](.projor/project.pglobal.yaml)_\",\n    \"main\": \"lib/index.js\",\n    \"types\": \"types/index.d.ts\",\n    \"devDependencies\": {\n        \"@types/node\": \"^22.6.1\",\n        \"typescript\": \"^5.6.2\",\n        \"chai\": \"^4.5.0\",\n        \"mocha\": \"^10.7.3\"\n    },\n    \"scripts\": {\n        \"build\": \"tsc\",\n        \"test\": \"mocha\"\n    }\n}\n",
      "contentHash": "e30cb2532e6cd936131e367dc6c0d97ca064db1f54ff3d0a80fe4a83fa9bfb28",
      "noWriteIfExists": false
    },
    {
      "filename": "README.md",
      "content": "# Backend Client Node\n\nThis is a [ProJor](https://projor.io) template, that generates a _TypeScript Node.JS Client Library_ for a _CRUD API_. See the [`.entities`](.projor/.entities) file on how to define the supported resources.\n\nThe API supported by this client is the same as the one provided by CRUD API Web Service templates, such as [template-spring-boot-crud](https://github.com/SIOCODE-Open/template-spring-boot-crud).\n\n[See README inside .projor/ for template customization details and internals](.projor/README.md).\n\n_You can edit this description in [`.projor/project.pglobal.yaml`](.projor/project.pglobal.yaml)_\n\n## License\n\nThis template is licensed under the [MIT License](LICENSE.md).\n\n[ProJor](https://projor.io) is licensed under either the [ProJor Free License](https://license.projor.io) or the [ProJor Commercial License](https://license.projor.io).",
      "contentHash": "c54ca53c546682ef2ededb6afb1a8f1c9b7d776b06d40e264b8c45851b605f67",
      "noWriteIfExists": false
    },
    {
      "filename": "src/index.ts",
      "content": "/** No description. */\nexport interface IOrganizationUnit {\n    /** The unique identifier for this Organization Unit */\n    id: string;\n\n    /** No description. */\n    name: string;\n}\n\n/** DTO for a new Organization Unit */\nexport interface INewOrganizationUnit {\n    /** No description. */\n    name?: string | null;\n}\n\n/** DTO for filtering Organization Unit objects */\nexport interface IOrganizationUnitFilter {\n    and?: Array<IOrganizationUnitFilter>;\n    or?: Array<IOrganizationUnitFilter>;\n    not?: IOrganizationUnitFilter;\n    name?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n        contains?: string;\n        notContains?: string;\n        startsWith?: string;\n        notStartsWith?: string;\n        endsWith?: string;\n        notEndsWith?: string;\n    };\n    id?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n    };\n}\n\nexport type IOrganizationUnitSort =\n    | \"id__asc\"\n    | \"id__desc\"\n    | \"name__asc\"\n    | \"name__desc\";\n\nexport interface IOrganizationUnitService {\n    listAll(opts?: {\n        offset: number;\n        limit: number;\n        sort: IOrganizationUnitSort;\n    }): Promise<Array<IOrganizationUnit>>;\n    getById(id: string): Promise<IOrganizationUnit | null>;\n    countAll(): Promise<number>;\n    search(\n        filter: IOrganizationUnitFilter,\n        opts?: {\n            offset: number;\n            limit: number;\n            sort: IOrganizationUnitSort;\n        }\n    );\n    countFor(filter: IOrganizationUnitFilter): Promise<number>;\n    create(\n        newOrganizationUnit: INewOrganizationUnit\n    ): Promise<IOrganizationUnit>;\n    updateName(id: string, name: string): Promise<void>;\n    clearName(id: string): Promise<void>;\n    remove(id: string): Promise<void>;\n}\n\nclass OrganizationUnitServiceImpl implements IOrganizationUnitService {\n    constructor(\n        private _baseUrl: string = \"http://localhost:8080/backend/v1\",\n        private _headers: Record<string, any> = {}\n    ) {}\n\n    async listAll(opts?: {\n        offset: number;\n        limit: number;\n        sort: IOrganizationUnitSort;\n    }): Promise<Array<IOrganizationUnit>> {\n        let requestUrl = `${this._baseUrl}/organization-unit`;\n        if (opts) {\n            const params = new URLSearchParams();\n            if (opts.offset) {\n                params.append(\"offset\", opts.offset.toString());\n            }\n            if (opts.limit) {\n                params.append(\"limit\", opts.limit.toString());\n            }\n            if (opts.sort) {\n                params.append(\"sort\", opts.sort);\n            }\n            requestUrl += `?${params.toString()}`;\n        }\n        const response = await fetch(requestUrl, {\n            headers: this._headers,\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling GET ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async countAll(): Promise<number> {\n        const response = await fetch(\n            `${this._baseUrl}/organization-unit/count`,\n            {\n                headers: this._headers,\n                credentials: \"include\",\n            }\n        );\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling GET ${this._baseUrl}/organization-unit/count: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async getById(id: string): Promise<IOrganizationUnit | null> {\n        const response = await fetch(\n            `${this._baseUrl}/organization-unit/${id}`,\n            {\n                headers: this._headers,\n                credentials: \"include\",\n            }\n        );\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling GET ${this._baseUrl}/organization-unit/${id}: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async search(\n        filter: IOrganizationUnitFilter,\n        opts?: {\n            offset: number;\n            limit: number;\n            sort: IOrganizationUnitSort;\n        }\n    ) {\n        let requestUrl = `${this._baseUrl}/organization-unit/search`;\n        if (opts) {\n            const params = new URLSearchParams();\n            if (opts.offset) {\n                params.append(\"offset\", opts.offset.toString());\n            }\n            if (opts.limit) {\n                params.append(\"limit\", opts.limit.toString());\n            }\n            if (opts.sort) {\n                params.append(\"sort\", opts.sort);\n            }\n            requestUrl += `?${params.toString()}`;\n        }\n        const response = await fetch(requestUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(filter),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling POST ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async countFor(filter: IOrganizationUnitFilter): Promise<number> {\n        const response = await fetch(\n            `${this._baseUrl}/organization-unit/search/count`,\n            {\n                method: \"POST\",\n                headers: {\n                    \"Content-Type\": \"application/json\",\n                    ...this._headers,\n                },\n                body: JSON.stringify(filter),\n                credentials: \"include\",\n            }\n        );\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling POST ${this._baseUrl}/organization-unit/search/count: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async create(\n        newOrganizationUnit: INewOrganizationUnit\n    ): Promise<IOrganizationUnit> {\n        const response = await fetch(`${this._baseUrl}/organization-unit`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(newOrganizationUnit),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling POST ${this._baseUrl}/organization-unit: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async updateName(id: string, name: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/organization-unit/${id}/name`;\n        const response = await fetch(requestUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(name),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling POST ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async clearName(id: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/organization-unit/${id}/name`;\n        const response = await fetch(requestUrl, {\n            method: \"DELETE\",\n            headers: this._headers,\n            credentials: \"include\",\n            body: JSON.stringify(\"\"),\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling DELETE ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async remove(id: string): Promise<void> {\n        const response = await fetch(\n            `${this._baseUrl}/organization-unit/${id}`,\n            {\n                method: \"DELETE\",\n                headers: this._headers,\n                credentials: \"include\",\n            }\n        );\n        if (!response.ok) {\n            throw new Error(\n                `[OrganizationUnitService] Failed calling DELETE ${this._baseUrl}/organization-unit/${id}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n}\n\nexport function createOrganizationUnitService(\n    baseUrl: string = \"http://localhost:8080/backend/v1\",\n    headers: Record<string, any> = {}\n): IOrganizationUnitService {\n    return new OrganizationUnitServiceImpl(baseUrl, headers);\n}\n\n/** An employee */\nexport interface IEmployee {\n    /** The unique identifier for this Employee */\n    id: string;\n\n    /** No description. */\n    firstName: string;\n\n    /** No description. */\n    lastName: string;\n\n    /** Org unit of employee */\n    orgUnit: string;\n}\n\n/** DTO for a new Employee */\nexport interface INewEmployee {\n    /** No description. */\n    firstName?: string | null;\n\n    /** No description. */\n    lastName?: string | null;\n\n    /** Org unit of employee */\n    orgUnit?: string | null;\n}\n\n/** DTO for filtering Employee objects */\nexport interface IEmployeeFilter {\n    and?: Array<IEmployeeFilter>;\n    or?: Array<IEmployeeFilter>;\n    not?: IEmployeeFilter;\n    firstName?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n        contains?: string;\n        notContains?: string;\n        startsWith?: string;\n        notStartsWith?: string;\n        endsWith?: string;\n        notEndsWith?: string;\n    };\n    lastName?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n        contains?: string;\n        notContains?: string;\n        startsWith?: string;\n        notStartsWith?: string;\n        endsWith?: string;\n        notEndsWith?: string;\n    };\n    id?: {\n        equals?: string;\n        notEquals?: string;\n        in?: Array<string>;\n        notIn?: Array<string>;\n    };\n}\n\nexport type IEmployeeSort =\n    | \"id__asc\"\n    | \"id__desc\"\n    | \"firstName__asc\"\n    | \"firstName__desc\"\n    | \"lastName__asc\"\n    | \"lastName__desc\";\n\nexport interface IEmployeeService {\n    listAll(opts?: {\n        offset: number;\n        limit: number;\n        sort: IEmployeeSort;\n    }): Promise<Array<IEmployee>>;\n    getById(id: string): Promise<IEmployee | null>;\n    countAll(): Promise<number>;\n    search(\n        filter: IEmployeeFilter,\n        opts?: {\n            offset: number;\n            limit: number;\n            sort: IEmployeeSort;\n        }\n    );\n    countFor(filter: IEmployeeFilter): Promise<number>;\n    create(newEmployee: INewEmployee): Promise<IEmployee>;\n    updateFirstName(id: string, firstName: string): Promise<void>;\n    clearFirstName(id: string): Promise<void>;\n    updateLastName(id: string, lastName: string): Promise<void>;\n    clearLastName(id: string): Promise<void>;\n    updateOrgUnit(id: string, orgUnit: string): Promise<void>;\n    clearOrgUnit(id: string): Promise<void>;\n    remove(id: string): Promise<void>;\n}\n\nclass EmployeeServiceImpl implements IEmployeeService {\n    constructor(\n        private _baseUrl: string = \"http://localhost:8080/backend/v1\",\n        private _headers: Record<string, any> = {}\n    ) {}\n\n    async listAll(opts?: {\n        offset: number;\n        limit: number;\n        sort: IEmployeeSort;\n    }): Promise<Array<IEmployee>> {\n        let requestUrl = `${this._baseUrl}/employee`;\n        if (opts) {\n            const params = new URLSearchParams();\n            if (opts.offset) {\n                params.append(\"offset\", opts.offset.toString());\n            }\n            if (opts.limit) {\n                params.append(\"limit\", opts.limit.toString());\n            }\n            if (opts.sort) {\n                params.append(\"sort\", opts.sort);\n            }\n            requestUrl += `?${params.toString()}`;\n        }\n        const response = await fetch(requestUrl, {\n            headers: this._headers,\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling GET ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async countAll(): Promise<number> {\n        const response = await fetch(`${this._baseUrl}/employee/count`, {\n            headers: this._headers,\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling GET ${this._baseUrl}/employee/count: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async getById(id: string): Promise<IEmployee | null> {\n        const response = await fetch(`${this._baseUrl}/employee/${id}`, {\n            headers: this._headers,\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling GET ${this._baseUrl}/employee/${id}: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async search(\n        filter: IEmployeeFilter,\n        opts?: {\n            offset: number;\n            limit: number;\n            sort: IEmployeeSort;\n        }\n    ) {\n        let requestUrl = `${this._baseUrl}/employee/search`;\n        if (opts) {\n            const params = new URLSearchParams();\n            if (opts.offset) {\n                params.append(\"offset\", opts.offset.toString());\n            }\n            if (opts.limit) {\n                params.append(\"limit\", opts.limit.toString());\n            }\n            if (opts.sort) {\n                params.append(\"sort\", opts.sort);\n            }\n            requestUrl += `?${params.toString()}`;\n        }\n        const response = await fetch(requestUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(filter),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling POST ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async countFor(filter: IEmployeeFilter): Promise<number> {\n        const response = await fetch(`${this._baseUrl}/employee/search/count`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(filter),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling POST ${this._baseUrl}/employee/search/count: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async create(newEmployee: INewEmployee): Promise<IEmployee> {\n        const response = await fetch(`${this._baseUrl}/employee`, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(newEmployee),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling POST ${this._baseUrl}/employee: ${response.status} ${response.statusText}`\n            );\n        }\n        return await response.json();\n    }\n\n    async updateFirstName(id: string, firstName: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/employee/${id}/first-name`;\n        const response = await fetch(requestUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(firstName),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling POST ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async clearFirstName(id: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/employee/${id}/first-name`;\n        const response = await fetch(requestUrl, {\n            method: \"DELETE\",\n            headers: this._headers,\n            credentials: \"include\",\n            body: JSON.stringify(\"\"),\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling DELETE ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async updateLastName(id: string, lastName: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/employee/${id}/last-name`;\n        const response = await fetch(requestUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(lastName),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling POST ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async clearLastName(id: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/employee/${id}/last-name`;\n        const response = await fetch(requestUrl, {\n            method: \"DELETE\",\n            headers: this._headers,\n            credentials: \"include\",\n            body: JSON.stringify(\"\"),\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling DELETE ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async updateOrgUnit(id: string, orgUnit: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/employee/${id}/org-unit`;\n        const response = await fetch(requestUrl, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...this._headers,\n            },\n            body: JSON.stringify(orgUnit),\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling POST ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async clearOrgUnit(id: string): Promise<void> {\n        const requestUrl = `${this._baseUrl}/employee/${id}/org-unit`;\n        const response = await fetch(requestUrl, {\n            method: \"DELETE\",\n            headers: this._headers,\n            credentials: \"include\",\n            body: JSON.stringify(\"\"),\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling DELETE ${requestUrl}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n    async remove(id: string): Promise<void> {\n        const response = await fetch(`${this._baseUrl}/employee/${id}`, {\n            method: \"DELETE\",\n            headers: this._headers,\n            credentials: \"include\",\n        });\n        if (!response.ok) {\n            throw new Error(\n                `[EmployeeService] Failed calling DELETE ${this._baseUrl}/employee/${id}: ${response.status} ${response.statusText}`\n            );\n        }\n    }\n}\n\nexport function createEmployeeService(\n    baseUrl: string = \"http://localhost:8080/backend/v1\",\n    headers: Record<string, any> = {}\n): IEmployeeService {\n    return new EmployeeServiceImpl(baseUrl, headers);\n}\n",
      "contentHash": "4a419bbceac4d2cdf0f49a64252c02c8a4cd1c6fcc410a8dc6e9781d26dfece9",
      "noWriteIfExists": false
    },
    {
      "filename": "test/index.test.js",
      "content": "const client = require(\"../lib/index\");\nconst { expect } = require(\"chai\");\n\nfunction randomString(length = 10) {\n    return Math.random()\n        .toString(36)\n        .substring(2, 2 + length);\n}\n\nfunction randomInteger(min = 0, max = 1000) {\n    return Math.floor(Math.random() * (max - min + 1)) + min;\n}\n\nfunction randomBoolean() {\n    return Math.random() >= 0.5;\n}\n\nfunction randomFloat(min = 0, max = 1000) {\n    return Math.random() * (max - min) + min;\n}\n\nfunction randomDouble(min = 0, max = 1000) {\n    return Math.random() * (max - min) + min;\n}\n\ndescribe(\"Backend Client Node Tests\", () => {\n    const backendUrl =\n        process.env.BACKEND_CLIENT_NODE_TEST_BACKEND_URL ||\n        \"http://localhost:8080/backend/v1\";\n    const authLoginName =\n        process.env.BACKEND_CLIENT_NODE_TEST_AUTH_LOGIN_NAME || \"admin\";\n    const authLoginPassword =\n        process.env.BACKEND_CLIENT_NODE_TEST_AUTH_LOGIN_PASSWORD || \"admin\";\n    const authJwtToken =\n        process.env.BACKEND_CLIENT_NODE_TEST_AUTH_JWT_TOKEN || null;\n\n    describe(\"Organization Unit Service Tests (/backend/v1/organization-unit)\", () => {\n        var authToken = null;\n\n        const doLogin = async () => {\n            if (authJwtToken) {\n                authToken = authJwtToken;\n                console.log(\n                    \"Using JWT token from configuration for authentication, skipping login ...\"\n                );\n                return authToken;\n            }\n\n            try {\n                const loginResponse = await fetch(`${backendUrl}/auth/login`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({\n                        loginName: authLoginName,\n                        password: authLoginPassword,\n                    }),\n                });\n                if (!loginResponse.ok) {\n                    throw new Error(\n                        \"Cannot run tests: login endpoint returned status \" +\n                            loginResponse.status +\n                            \" \" +\n                            loginResponse.statusText\n                    );\n                }\n                // Token is raw the body\n                authToken = await loginResponse.text();\n                return authToken;\n            } catch (error) {\n                const isConnRefused = error.message.includes(\"ECONNREFUSED\");\n                if (isConnRefused) {\n                    throw new Error(\n                        [error],\n                        \"Cannot run tests: connection refused. Is the backend running?\"\n                    );\n                }\n                throw new AggregateError(\n                    [error],\n                    \"Cannot run tests: login failed with error \" + error.message\n                );\n            }\n        };\n\n        const createService = async () => {\n            const token = await doLogin();\n            return client.createOrganizationUnitService(backendUrl, {\n                Authorization: `Bearer ${token}`,\n                \"Content-Type\": \"application/json\",\n                Accept: \"application/json\",\n            });\n        };\n\n        it(\"GET / (no opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll();\n            expect(list).to.be.an(\"array\");\n        });\n\n        it(\"GET / (with opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll({\n                offset: 10,\n                limit: 10,\n                sort: \"id__desc\",\n            });\n            expect(list).to.be.an(\"array\");\n            expect(list.length).to.be.lessThanOrEqual(10);\n        });\n\n        it(\"GET /count\", async () => {\n            const service = await createService();\n            const count = await service.countAll();\n            expect(count).to.be.greaterThanOrEqual(0);\n        });\n\n        // New test: Create a new entity with random attributes and null associations\n        it(\"POST / - create new Organization Unit with null associations\", async () => {\n            const service = await createService();\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            expect(createdOrganizationUnit).to.be.an(\"object\");\n            expect(createdOrganizationUnit).to.have.property(\"id\");\n            expect(createdOrganizationUnit).to.have.property(\n                \"name\",\n                newOrganizationUnit.name\n            );\n        });\n\n        it(\"GET /:id\", async () => {\n            const service = await createService();\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            const retrievedOrganizationUnit = await service.getById(id);\n            expect(retrievedOrganizationUnit).to.be.an(\"object\");\n            expect(retrievedOrganizationUnit).to.have.property(\"id\", id);\n        });\n\n        // New test: Create a new entity with random attributes and non-null associations\n        it(\"POST / - create new Organization Unit with non-null associations\", async () => {\n            const service = await createService();\n\n            // Create related entities for associations\n            const associations = {};\n\n            const newOrganizationUnit = {\n                name: randomString(),\n                ...associations,\n            };\n\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            expect(createdOrganizationUnit).to.be.an(\"object\");\n            expect(createdOrganizationUnit).to.have.property(\"id\");\n            expect(createdOrganizationUnit).to.have.property(\n                \"name\",\n                newOrganizationUnit.name\n            );\n        });\n\n        // New test: Update an attribute with a random value\n        it(\"POST /:id/name - update attribute name\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            // Update the attribute\n            const updatedValue = randomString();\n            await service.updateName(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedOrganizationUnit = await service.getById(id);\n            expect(updatedOrganizationUnit).to.have.property(\n                \"name\",\n                updatedValue\n            );\n        });\n\n        // New test: Clear an attribute\n        it(\"DELETE /:id/name - clear attribute name\", async () => {\n            const service = await createService();\n            // Create a new entity with the attribute set\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            // Clear the attribute\n            await service.clearName(id); // Returns Promise<void>\n            // Retrieve and verify the attribute is cleared\n            const updatedOrganizationUnit = await service.getById(id);\n            expect(updatedOrganizationUnit).to.have.property(\"name\").that.is\n                .null;\n        });\n\n        // New test: Update an association with null and non-null values\n\n        // New test: Delete an entity\n        it(\"DELETE /:id - remove Organization Unit\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newOrganizationUnit = {\n                name: randomString(),\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            const id = createdOrganizationUnit.id;\n            // Delete the entity\n            await service.remove(id);\n            // Verify the entity has been deleted\n            let error = null;\n            try {\n                await service.getById(id);\n            } catch (err) {\n                error = err;\n            }\n            expect(error).to.not.be.null;\n        });\n\n        // New test: Search entities\n        it(\"POST /search - search Organization Unit entities\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newOrganizationUnit = {\n                name: uniqueValue,\n            };\n            const createdOrganizationUnit = await service.create(\n                newOrganizationUnit\n            );\n            // Search for the entity using the unique attribute\n            const filter = {\n                name: {\n                    equals: uniqueValue,\n                },\n            };\n            const results = await service.search(filter);\n            expect(results).to.be.an(\"array\");\n            const found = results.some(\n                (e) => e.id === createdOrganizationUnit.id\n            );\n            expect(found).to.be.true;\n        });\n\n        // New test: Count entities matching a filter\n        it(\"POST /search/count - count Organization Unit entities matching a filter\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newOrganizationUnit = {\n                name: uniqueValue,\n            };\n            await service.create(newOrganizationUnit);\n            // Count entities matching the filter\n            const filter = {\n                name: {\n                    equals: uniqueValue,\n                },\n            };\n            const count = await service.countFor(filter);\n            expect(count).to.be.a(\"number\");\n            expect(count).to.be.greaterThanOrEqual(1);\n        });\n    });\n    describe(\"Employee Service Tests (/backend/v1/employee)\", () => {\n        var authToken = null;\n\n        const doLogin = async () => {\n            if (authJwtToken) {\n                authToken = authJwtToken;\n                console.log(\n                    \"Using JWT token from configuration for authentication, skipping login ...\"\n                );\n                return authToken;\n            }\n\n            try {\n                const loginResponse = await fetch(`${backendUrl}/auth/login`, {\n                    method: \"POST\",\n                    headers: {\n                        \"Content-Type\": \"application/json\",\n                    },\n                    body: JSON.stringify({\n                        loginName: authLoginName,\n                        password: authLoginPassword,\n                    }),\n                });\n                if (!loginResponse.ok) {\n                    throw new Error(\n                        \"Cannot run tests: login endpoint returned status \" +\n                            loginResponse.status +\n                            \" \" +\n                            loginResponse.statusText\n                    );\n                }\n                // Token is raw the body\n                authToken = await loginResponse.text();\n                return authToken;\n            } catch (error) {\n                const isConnRefused = error.message.includes(\"ECONNREFUSED\");\n                if (isConnRefused) {\n                    throw new Error(\n                        [error],\n                        \"Cannot run tests: connection refused. Is the backend running?\"\n                    );\n                }\n                throw new AggregateError(\n                    [error],\n                    \"Cannot run tests: login failed with error \" + error.message\n                );\n            }\n        };\n\n        const createService = async () => {\n            const token = await doLogin();\n            return client.createEmployeeService(backendUrl, {\n                Authorization: `Bearer ${token}`,\n                \"Content-Type\": \"application/json\",\n                Accept: \"application/json\",\n            });\n        };\n\n        it(\"GET / (no opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll();\n            expect(list).to.be.an(\"array\");\n        });\n\n        it(\"GET / (with opts)\", async () => {\n            const service = await createService();\n            const list = await service.listAll({\n                offset: 10,\n                limit: 10,\n                sort: \"id__desc\",\n            });\n            expect(list).to.be.an(\"array\");\n            expect(list.length).to.be.lessThanOrEqual(10);\n        });\n\n        it(\"GET /count\", async () => {\n            const service = await createService();\n            const count = await service.countAll();\n            expect(count).to.be.greaterThanOrEqual(0);\n        });\n\n        // New test: Create a new entity with random attributes and null associations\n        it(\"POST / - create new Employee with null associations\", async () => {\n            const service = await createService();\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnit: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            expect(createdEmployee).to.be.an(\"object\");\n            expect(createdEmployee).to.have.property(\"id\");\n            expect(createdEmployee).to.have.property(\n                \"firstName\",\n                newEmployee.firstName\n            );\n            expect(createdEmployee).to.have.property(\n                \"lastName\",\n                newEmployee.lastName\n            );\n        });\n\n        it(\"GET /:id\", async () => {\n            const service = await createService();\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnit: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            const retrievedEmployee = await service.getById(id);\n            expect(retrievedEmployee).to.be.an(\"object\");\n            expect(retrievedEmployee).to.have.property(\"id\", id);\n        });\n\n        // New test: Create a new entity with random attributes and non-null associations\n        it(\"POST / - create new Employee with non-null associations\", async () => {\n            const service = await createService();\n\n            // Create related entities for associations\n            const associations = {};\n            // Assuming the associated entity is OrganizationUnit\n            const relatedOrgUnitService =\n                await client.createOrganizationUnitService(backendUrl, {\n                    Authorization: `Bearer ${authToken}`,\n                });\n            const relatedOrgUnit = await relatedOrgUnitService.create({\n                name: randomString(),\n            });\n            associations[\"orgUnitId\"] = relatedOrgUnit.id;\n\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                ...associations,\n            };\n\n            const createdEmployee = await service.create(newEmployee);\n            expect(createdEmployee).to.be.an(\"object\");\n            expect(createdEmployee).to.have.property(\"id\");\n            expect(createdEmployee).to.have.property(\n                \"firstName\",\n                newEmployee.firstName\n            );\n            expect(createdEmployee).to.have.property(\n                \"lastName\",\n                newEmployee.lastName\n            );\n            expect(createdEmployee).to.have.property(\n                \"orgUnitId\",\n                associations[\"orgUnitId\"]\n            );\n        });\n\n        // New test: Update an attribute with a random value\n        it(\"POST /:id/firstName - update attribute firstName\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the attribute\n            const updatedValue = randomString();\n            await service.updateFirstName(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"firstName\", updatedValue);\n        });\n        it(\"POST /:id/lastName - update attribute lastName\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the attribute\n            const updatedValue = randomString();\n            await service.updateLastName(id, updatedValue); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"lastName\", updatedValue);\n        });\n\n        // New test: Clear an attribute\n        it(\"DELETE /:id/firstName - clear attribute firstName\", async () => {\n            const service = await createService();\n            // Create a new entity with the attribute set\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Clear the attribute\n            await service.clearFirstName(id); // Returns Promise<void>\n            // Retrieve and verify the attribute is cleared\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"firstName\").that.is.null;\n        });\n        it(\"DELETE /:id/lastName - clear attribute lastName\", async () => {\n            const service = await createService();\n            // Create a new entity with the attribute set\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Clear the attribute\n            await service.clearLastName(id); // Returns Promise<void>\n            // Retrieve and verify the attribute is cleared\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\"lastName\").that.is.null;\n        });\n\n        // New test: Update an association with null and non-null values\n        it(\"POST /:id/orgUnit - update association orgUnit with non-null value\", async () => {\n            const service = await createService();\n            // Create related entity\n            const relatedOrgUnitService =\n                await client.createOrganizationUnitService(backendUrl, {\n                    Authorization: `Bearer ${authToken}`,\n                });\n            const relatedOrgUnit = await relatedOrgUnitService.create({\n                name: randomString(),\n            });\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Update the association\n            await service.updateOrgUnit(id, relatedOrgUnit.id); // Returns Promise<void>\n            // Retrieve and verify the updated entity\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee).to.have.property(\n                \"orgUnitId\",\n                relatedOrgUnit.id\n            );\n        });\n\n        it(\"DELETE /:id/orgUnit - clear association orgUnit\", async () => {\n            const service = await createService();\n            // Create related entity\n            const relatedOrgUnitService =\n                await client.createOrganizationUnitService(backendUrl, {\n                    Authorization: `Bearer ${authToken}`,\n                });\n            const relatedOrgUnit = await relatedOrgUnitService.create({\n                name: randomString(),\n            });\n            // Create a new entity with the association set\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnitId: relatedOrgUnit.id,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Clear the association\n            await service.clearOrgUnit(id); // Returns Promise<void>\n            // Retrieve and verify the association is cleared\n            const updatedEmployee = await service.getById(id);\n            expect(updatedEmployee[\"orgUnitId\"]).to.be.null;\n        });\n\n        // New test: Delete an entity\n        it(\"DELETE /:id - remove Employee\", async () => {\n            const service = await createService();\n            // Create a new entity\n            const newEmployee = {\n                firstName: randomString(),\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            const id = createdEmployee.id;\n            // Delete the entity\n            await service.remove(id);\n            // Verify the entity has been deleted\n            let error = null;\n            try {\n                await service.getById(id);\n            } catch (err) {\n                error = err;\n            }\n            expect(error).to.not.be.null;\n        });\n\n        // New test: Search entities\n        it(\"POST /search - search Employee entities\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newEmployee = {\n                firstName: uniqueValue,\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            const createdEmployee = await service.create(newEmployee);\n            // Search for the entity using the unique attribute\n            const filter = {\n                firstName: {\n                    equals: uniqueValue,\n                },\n            };\n            const results = await service.search(filter);\n            expect(results).to.be.an(\"array\");\n            const found = results.some((e) => e.id === createdEmployee.id);\n            expect(found).to.be.true;\n        });\n\n        // New test: Count entities matching a filter\n        it(\"POST /search/count - count Employee entities matching a filter\", async () => {\n            const service = await createService();\n            // Create a unique attribute value for testing\n            const uniqueValue = `test-${randomString(5)}-${Date.now()}`;\n            // Create a new entity with the unique value\n            const newEmployee = {\n                firstName: uniqueValue,\n                lastName: randomString(),\n                orgUnitId: null,\n            };\n            await service.create(newEmployee);\n            // Count entities matching the filter\n            const filter = {\n                firstName: {\n                    equals: uniqueValue,\n                },\n            };\n            const count = await service.countFor(filter);\n            expect(count).to.be.a(\"number\");\n            expect(count).to.be.greaterThanOrEqual(1);\n        });\n    });\n});\n",
      "contentHash": "55a9baca89fb7789ac59def13b662e670b01fd49479b8c6287eecd26640e5878",
      "noWriteIfExists": false
    },
    {
      "filename": "tsconfig.json",
      "content": "{\n    \"compilerOptions\": {\n        \"target\": \"ES2015\",\n        \"module\": \"CommonJS\",\n        \"moduleResolution\": \"Node\",\n        \"esModuleInterop\": true,\n        \"skipLibCheck\": true,\n        \"allowSyntheticDefaultImports\": true,\n        \"outDir\": \"lib\",\n        \"declaration\": true,\n        \"declarationDir\": \"types\",\n        \"sourceMap\": true,\n        \"declarationMap\": true\n    },\n    \"include\": [\"src/**/*.ts\"],\n    \"exclude\": [\"node_modules\"]\n}\n",
      "contentHash": "1f26459f4c4bb11cddbb260e6f02cb44196b31966aef4eeebcab1af5e3b44688",
      "noWriteIfExists": false
    }
  ]
}